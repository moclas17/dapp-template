/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pino";
exports.ids = ["vendor-chunks/pino"];
exports.modules = {

/***/ "(ssr)/./node_modules/pino/lib/caller.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/caller.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction noOpPrepareStackTrace (_, stack) {\n  return stack\n}\n\nmodule.exports = function getCallers () {\n  const originalPrepare = Error.prepareStackTrace\n  Error.prepareStackTrace = noOpPrepareStackTrace\n  const stack = new Error().stack\n  Error.prepareStackTrace = originalPrepare\n\n  if (!Array.isArray(stack)) {\n    return undefined\n  }\n\n  const entries = stack.slice(2)\n\n  const fileNames = []\n\n  for (const entry of entries) {\n    if (!entry) {\n      continue\n    }\n\n    fileNames.push(entry.getFileName())\n  }\n\n  return fileNames\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY2FsbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NhbGxlci5qcz9hNGUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBub09wUHJlcGFyZVN0YWNrVHJhY2UgKF8sIHN0YWNrKSB7XG4gIHJldHVybiBzdGFja1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldENhbGxlcnMgKCkge1xuICBjb25zdCBvcmlnaW5hbFByZXBhcmUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZVxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG5vT3BQcmVwYXJlU3RhY2tUcmFjZVxuICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZ2luYWxQcmVwYXJlXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGVudHJpZXMgPSBzdGFjay5zbGljZSgyKVxuXG4gIGNvbnN0IGZpbGVOYW1lcyA9IFtdXG5cbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBmaWxlTmFtZXMucHVzaChlbnRyeS5nZXRGaWxlTmFtZSgpKVxuICB9XG5cbiAgcmV0dXJuIGZpbGVOYW1lc1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/caller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/constants.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Represents default log level values\n *\n * @enum {number}\n */\nconst DEFAULT_LEVELS = {\n  trace: 10,\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  fatal: 60\n}\n\n/**\n * Represents sort order direction: `ascending` or `descending`\n *\n * @enum {string}\n */\nconst SORTING_ORDER = {\n  ASC: 'ASC',\n  DESC: 'DESC'\n}\n\nmodule.exports = {\n  DEFAULT_LEVELS,\n  SORTING_ORDER\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NvbnN0YW50cy5qcz8wNmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBkZWZhdWx0IGxvZyBsZXZlbCB2YWx1ZXNcbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBERUZBVUxUX0xFVkVMUyA9IHtcbiAgdHJhY2U6IDEwLFxuICBkZWJ1ZzogMjAsXG4gIGluZm86IDMwLFxuICB3YXJuOiA0MCxcbiAgZXJyb3I6IDUwLFxuICBmYXRhbDogNjBcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHNvcnQgb3JkZXIgZGlyZWN0aW9uOiBgYXNjZW5kaW5nYCBvciBgZGVzY2VuZGluZ2BcbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBTT1JUSU5HX09SREVSID0ge1xuICBBU0M6ICdBU0MnLFxuICBERVNDOiAnREVTQydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIERFRkFVTFRfTEVWRUxTLFxuICBTT1JUSU5HX09SREVSXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/levels.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/levels.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint no-prototype-builtins: 0 */\nconst {\n  lsCacheSym,\n  levelValSym,\n  useOnlyCustomLevelsSym,\n  streamSym,\n  formattersSym,\n  hooksSym,\n  levelCompSym\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { noop, genLog } = __webpack_require__(/*! ./tools */ \"(ssr)/./node_modules/pino/lib/tools.js\")\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/pino/lib/constants.js\")\n\nconst levelMethods = {\n  fatal: (hook) => {\n    const logFatal = genLog(DEFAULT_LEVELS.fatal, hook)\n    return function (...args) {\n      const stream = this[streamSym]\n      logFatal.call(this, ...args)\n      if (typeof stream.flushSync === 'function') {\n        try {\n          stream.flushSync()\n        } catch (e) {\n          // https://github.com/pinojs/pino/pull/740#discussion_r346788313\n        }\n      }\n    }\n  },\n  error: (hook) => genLog(DEFAULT_LEVELS.error, hook),\n  warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),\n  info: (hook) => genLog(DEFAULT_LEVELS.info, hook),\n  debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),\n  trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)\n}\n\nconst nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {\n  o[DEFAULT_LEVELS[k]] = k\n  return o\n}, {})\n\nconst initialLsCache = Object.keys(nums).reduce((o, k) => {\n  o[k] = '{\"level\":' + Number(k)\n  return o\n}, {})\n\nfunction genLsCache (instance) {\n  const formatter = instance[formattersSym].level\n  const { labels } = instance.levels\n  const cache = {}\n  for (const label in labels) {\n    const level = formatter(labels[label], Number(label))\n    cache[label] = JSON.stringify(level).slice(0, -1)\n  }\n  instance[lsCacheSym] = cache\n  return instance\n}\n\nfunction isStandardLevel (level, useOnlyCustomLevels) {\n  if (useOnlyCustomLevels) {\n    return false\n  }\n\n  switch (level) {\n    case 'fatal':\n    case 'error':\n    case 'warn':\n    case 'info':\n    case 'debug':\n    case 'trace':\n      return true\n    default:\n      return false\n  }\n}\n\nfunction setLevel (level) {\n  const { labels, values } = this.levels\n  if (typeof level === 'number') {\n    if (labels[level] === undefined) throw Error('unknown level value' + level)\n    level = labels[level]\n  }\n  if (values[level] === undefined) throw Error('unknown level ' + level)\n  const preLevelVal = this[levelValSym]\n  const levelVal = this[levelValSym] = values[level]\n  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym]\n  const levelComparison = this[levelCompSym]\n  const hook = this[hooksSym].logMethod\n\n  for (const key in values) {\n    if (levelComparison(values[key], levelVal) === false) {\n      this[key] = noop\n      continue\n    }\n    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook)\n  }\n\n  this.emit(\n    'level-change',\n    level,\n    levelVal,\n    labels[preLevelVal],\n    preLevelVal,\n    this\n  )\n}\n\nfunction getLevel (level) {\n  const { levels, levelVal } = this\n  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)\n  return (levels && levels.labels) ? levels.labels[levelVal] : ''\n}\n\nfunction isLevelEnabled (logLevel) {\n  const { values } = this.levels\n  const logLevelVal = values[logLevel]\n  return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym])\n}\n\n/**\n * Determine if the given `current` level is enabled by comparing it\n * against the current threshold (`expected`).\n *\n * @param {SORTING_ORDER} direction comparison direction \"ASC\" or \"DESC\"\n * @param {number} current current log level number representation\n * @param {number} expected threshold value to compare with\n * @returns {boolean}\n */\nfunction compareLevel (direction, current, expected) {\n  if (direction === SORTING_ORDER.DESC) {\n    return current <= expected\n  }\n\n  return current >= expected\n}\n\n/**\n * Create a level comparison function based on `levelComparison`\n * it could a default function which compares levels either in \"ascending\" or \"descending\" order or custom comparison function\n *\n * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function\n * @returns Function\n */\nfunction genLevelComparison (levelComparison) {\n  if (typeof levelComparison === 'string') {\n    return compareLevel.bind(null, levelComparison)\n  }\n\n  return levelComparison\n}\n\nfunction mappings (customLevels = null, useOnlyCustomLevels = false) {\n  const customNums = customLevels\n    /* eslint-disable */\n    ? Object.keys(customLevels).reduce((o, k) => {\n        o[customLevels[k]] = k\n        return o\n      }, {})\n    : null\n    /* eslint-enable */\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),\n    useOnlyCustomLevels ? null : nums,\n    customNums\n  )\n  const values = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : DEFAULT_LEVELS,\n    customLevels\n  )\n  return { labels, values }\n}\n\nfunction assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {\n  if (typeof defaultLevel === 'number') {\n    const values = [].concat(\n      Object.keys(customLevels || {}).map(key => customLevels[key]),\n      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),\n      Infinity\n    )\n    if (!values.includes(defaultLevel)) {\n      throw Error(`default level:${defaultLevel} must be included in custom levels`)\n    }\n    return\n  }\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : DEFAULT_LEVELS,\n    customLevels\n  )\n  if (!(defaultLevel in labels)) {\n    throw Error(`default level:${defaultLevel} must be included in custom levels`)\n  }\n}\n\nfunction assertNoLevelCollisions (levels, customLevels) {\n  const { labels, values } = levels\n  for (const k in customLevels) {\n    if (k in values) {\n      throw Error('levels cannot be overridden')\n    }\n    if (customLevels[k] in labels) {\n      throw Error('pre-existing level values cannot be used for new levels')\n    }\n  }\n}\n\n/**\n * Validates whether `levelComparison` is correct\n *\n * @throws Error\n * @param {SORTING_ORDER | Function} levelComparison - value to validate\n * @returns\n */\nfunction assertLevelComparison (levelComparison) {\n  if (typeof levelComparison === 'function') {\n    return\n  }\n\n  if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {\n    return\n  }\n\n  throw new Error('Levels comparison should be one of \"ASC\", \"DESC\" or \"function\" type')\n}\n\nmodule.exports = {\n  initialLsCache,\n  genLsCache,\n  levelMethods,\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  assertNoLevelCollisions,\n  assertDefaultLevelFound,\n  genLevelComparison,\n  assertLevelComparison\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbGV2ZWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVc7QUFDdkIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx1REFBUztBQUMxQyxRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsK0RBQWE7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0EsV0FBVztBQUNYO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWSxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxVQUFVLG1CQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2xldmVscy5qcz9iNzljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuY29uc3Qge1xuICBsc0NhY2hlU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgdXNlT25seUN1c3RvbUxldmVsc1N5bSxcbiAgc3RyZWFtU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBob29rc1N5bSxcbiAgbGV2ZWxDb21wU3ltXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgbm9vcCwgZ2VuTG9nIH0gPSByZXF1aXJlKCcuL3Rvb2xzJylcbmNvbnN0IHsgREVGQVVMVF9MRVZFTFMsIFNPUlRJTkdfT1JERVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgbGV2ZWxNZXRob2RzID0ge1xuICBmYXRhbDogKGhvb2spID0+IHtcbiAgICBjb25zdCBsb2dGYXRhbCA9IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5mYXRhbCwgaG9vaylcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXNbc3RyZWFtU3ltXVxuICAgICAgbG9nRmF0YWwuY2FsbCh0aGlzLCAuLi5hcmdzKVxuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZmx1c2hTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8vcHVsbC83NDAjZGlzY3Vzc2lvbl9yMzQ2Nzg4MzEzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiAoaG9vaykgPT4gZ2VuTG9nKERFRkFVTFRfTEVWRUxTLmVycm9yLCBob29rKSxcbiAgd2FybjogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy53YXJuLCBob29rKSxcbiAgaW5mbzogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5pbmZvLCBob29rKSxcbiAgZGVidWc6IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMuZGVidWcsIGhvb2spLFxuICB0cmFjZTogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy50cmFjZSwgaG9vaylcbn1cblxuY29uc3QgbnVtcyA9IE9iamVjdC5rZXlzKERFRkFVTFRfTEVWRUxTKS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgb1tERUZBVUxUX0xFVkVMU1trXV0gPSBrXG4gIHJldHVybiBvXG59LCB7fSlcblxuY29uc3QgaW5pdGlhbExzQ2FjaGUgPSBPYmplY3Qua2V5cyhudW1zKS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgb1trXSA9ICd7XCJsZXZlbFwiOicgKyBOdW1iZXIoaylcbiAgcmV0dXJuIG9cbn0sIHt9KVxuXG5mdW5jdGlvbiBnZW5Mc0NhY2hlIChpbnN0YW5jZSkge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBpbnN0YW5jZVtmb3JtYXR0ZXJzU3ltXS5sZXZlbFxuICBjb25zdCB7IGxhYmVscyB9ID0gaW5zdGFuY2UubGV2ZWxzXG4gIGNvbnN0IGNhY2hlID0ge31cbiAgZm9yIChjb25zdCBsYWJlbCBpbiBsYWJlbHMpIHtcbiAgICBjb25zdCBsZXZlbCA9IGZvcm1hdHRlcihsYWJlbHNbbGFiZWxdLCBOdW1iZXIobGFiZWwpKVxuICAgIGNhY2hlW2xhYmVsXSA9IEpTT04uc3RyaW5naWZ5KGxldmVsKS5zbGljZSgwLCAtMSlcbiAgfVxuICBpbnN0YW5jZVtsc0NhY2hlU3ltXSA9IGNhY2hlXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBpc1N0YW5kYXJkTGV2ZWwgKGxldmVsLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKSB7XG4gIGlmICh1c2VPbmx5Q3VzdG9tTGV2ZWxzKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSAnZmF0YWwnOlxuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICBjYXNlICd3YXJuJzpcbiAgICBjYXNlICdpbmZvJzpcbiAgICBjYXNlICdkZWJ1Zyc6XG4gICAgY2FzZSAndHJhY2UnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0TGV2ZWwgKGxldmVsKSB7XG4gIGNvbnN0IHsgbGFiZWxzLCB2YWx1ZXMgfSA9IHRoaXMubGV2ZWxzXG4gIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGxhYmVsc1tsZXZlbF0gPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3IoJ3Vua25vd24gbGV2ZWwgdmFsdWUnICsgbGV2ZWwpXG4gICAgbGV2ZWwgPSBsYWJlbHNbbGV2ZWxdXG4gIH1cbiAgaWYgKHZhbHVlc1tsZXZlbF0gPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3IoJ3Vua25vd24gbGV2ZWwgJyArIGxldmVsKVxuICBjb25zdCBwcmVMZXZlbFZhbCA9IHRoaXNbbGV2ZWxWYWxTeW1dXG4gIGNvbnN0IGxldmVsVmFsID0gdGhpc1tsZXZlbFZhbFN5bV0gPSB2YWx1ZXNbbGV2ZWxdXG4gIGNvbnN0IHVzZU9ubHlDdXN0b21MZXZlbHNWYWwgPSB0aGlzW3VzZU9ubHlDdXN0b21MZXZlbHNTeW1dXG4gIGNvbnN0IGxldmVsQ29tcGFyaXNvbiA9IHRoaXNbbGV2ZWxDb21wU3ltXVxuICBjb25zdCBob29rID0gdGhpc1tob29rc1N5bV0ubG9nTWV0aG9kXG5cbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgaWYgKGxldmVsQ29tcGFyaXNvbih2YWx1ZXNba2V5XSwgbGV2ZWxWYWwpID09PSBmYWxzZSkge1xuICAgICAgdGhpc1trZXldID0gbm9vcFxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdGhpc1trZXldID0gaXNTdGFuZGFyZExldmVsKGtleSwgdXNlT25seUN1c3RvbUxldmVsc1ZhbCkgPyBsZXZlbE1ldGhvZHNba2V5XShob29rKSA6IGdlbkxvZyh2YWx1ZXNba2V5XSwgaG9vaylcbiAgfVxuXG4gIHRoaXMuZW1pdChcbiAgICAnbGV2ZWwtY2hhbmdlJyxcbiAgICBsZXZlbCxcbiAgICBsZXZlbFZhbCxcbiAgICBsYWJlbHNbcHJlTGV2ZWxWYWxdLFxuICAgIHByZUxldmVsVmFsLFxuICAgIHRoaXNcbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRMZXZlbCAobGV2ZWwpIHtcbiAgY29uc3QgeyBsZXZlbHMsIGxldmVsVmFsIH0gPSB0aGlzXG4gIC8vIHByb3RlY3Rpb24gYWdhaW5zdCBwb3RlbnRpYWwgbG9zcyBvZiBQaW5vIHNjb3BlIGZyb20gc2VyaWFsaXplcnMgKGVkZ2UgY2FzZSB3aXRoIGNpcmN1bGFyIHJlZnMgLSBodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8vaXNzdWVzLzgzMylcbiAgcmV0dXJuIChsZXZlbHMgJiYgbGV2ZWxzLmxhYmVscykgPyBsZXZlbHMubGFiZWxzW2xldmVsVmFsXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzTGV2ZWxFbmFibGVkIChsb2dMZXZlbCkge1xuICBjb25zdCB7IHZhbHVlcyB9ID0gdGhpcy5sZXZlbHNcbiAgY29uc3QgbG9nTGV2ZWxWYWwgPSB2YWx1ZXNbbG9nTGV2ZWxdXG4gIHJldHVybiBsb2dMZXZlbFZhbCAhPT0gdW5kZWZpbmVkICYmIHRoaXNbbGV2ZWxDb21wU3ltXShsb2dMZXZlbFZhbCwgdGhpc1tsZXZlbFZhbFN5bV0pXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBgY3VycmVudGAgbGV2ZWwgaXMgZW5hYmxlZCBieSBjb21wYXJpbmcgaXRcbiAqIGFnYWluc3QgdGhlIGN1cnJlbnQgdGhyZXNob2xkIChgZXhwZWN0ZWRgKS5cbiAqXG4gKiBAcGFyYW0ge1NPUlRJTkdfT1JERVJ9IGRpcmVjdGlvbiBjb21wYXJpc29uIGRpcmVjdGlvbiBcIkFTQ1wiIG9yIFwiREVTQ1wiXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBjdXJyZW50IGxvZyBsZXZlbCBudW1iZXIgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCB0aHJlc2hvbGQgdmFsdWUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUxldmVsIChkaXJlY3Rpb24sIGN1cnJlbnQsIGV4cGVjdGVkKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFNPUlRJTkdfT1JERVIuREVTQykge1xuICAgIHJldHVybiBjdXJyZW50IDw9IGV4cGVjdGVkXG4gIH1cblxuICByZXR1cm4gY3VycmVudCA+PSBleHBlY3RlZFxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxldmVsIGNvbXBhcmlzb24gZnVuY3Rpb24gYmFzZWQgb24gYGxldmVsQ29tcGFyaXNvbmBcbiAqIGl0IGNvdWxkIGEgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyBsZXZlbHMgZWl0aGVyIGluIFwiYXNjZW5kaW5nXCIgb3IgXCJkZXNjZW5kaW5nXCIgb3JkZXIgb3IgY3VzdG9tIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1NPUlRJTkdfT1JERVIgfCBGdW5jdGlvbn0gbGV2ZWxDb21wYXJpc29uIHNvcnQgbGV2ZWxzIG9yZGVyIGRpcmVjdGlvbiBvciBjdXN0b20gY29tcGFyaXNvbiBmdW5jdGlvblxuICogQHJldHVybnMgRnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2VuTGV2ZWxDb21wYXJpc29uIChsZXZlbENvbXBhcmlzb24pIHtcbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVMZXZlbC5iaW5kKG51bGwsIGxldmVsQ29tcGFyaXNvbilcbiAgfVxuXG4gIHJldHVybiBsZXZlbENvbXBhcmlzb25cbn1cblxuZnVuY3Rpb24gbWFwcGluZ3MgKGN1c3RvbUxldmVscyA9IG51bGwsIHVzZU9ubHlDdXN0b21MZXZlbHMgPSBmYWxzZSkge1xuICBjb25zdCBjdXN0b21OdW1zID0gY3VzdG9tTGV2ZWxzXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICA/IE9iamVjdC5rZXlzKGN1c3RvbUxldmVscykucmVkdWNlKChvLCBrKSA9PiB7XG4gICAgICAgIG9bY3VzdG9tTGV2ZWxzW2tdXSA9IGtcbiAgICAgICAgcmV0dXJuIG9cbiAgICAgIH0sIHt9KVxuICAgIDogbnVsbFxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICBjb25zdCBsYWJlbHMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBJbmZpbml0eTogeyB2YWx1ZTogJ3NpbGVudCcgfSB9KSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gbnVsbCA6IG51bXMsXG4gICAgY3VzdG9tTnVtc1xuICApXG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7IHNpbGVudDogeyB2YWx1ZTogSW5maW5pdHkgfSB9KSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gbnVsbCA6IERFRkFVTFRfTEVWRUxTLFxuICAgIGN1c3RvbUxldmVsc1xuICApXG4gIHJldHVybiB7IGxhYmVscywgdmFsdWVzIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVmYXVsdExldmVsRm91bmQgKGRlZmF1bHRMZXZlbCwgY3VzdG9tTGV2ZWxzLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKSB7XG4gIGlmICh0eXBlb2YgZGVmYXVsdExldmVsID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdLmNvbmNhdChcbiAgICAgIE9iamVjdC5rZXlzKGN1c3RvbUxldmVscyB8fCB7fSkubWFwKGtleSA9PiBjdXN0b21MZXZlbHNba2V5XSksXG4gICAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gW10gOiBPYmplY3Qua2V5cyhudW1zKS5tYXAobGV2ZWwgPT4gK2xldmVsKSxcbiAgICAgIEluZmluaXR5XG4gICAgKVxuICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGRlZmF1bHRMZXZlbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBkZWZhdWx0IGxldmVsOiR7ZGVmYXVsdExldmVsfSBtdXN0IGJlIGluY2x1ZGVkIGluIGN1c3RvbSBsZXZlbHNgKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGxhYmVscyA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7IHNpbGVudDogeyB2YWx1ZTogSW5maW5pdHkgfSB9KSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gbnVsbCA6IERFRkFVTFRfTEVWRUxTLFxuICAgIGN1c3RvbUxldmVsc1xuICApXG4gIGlmICghKGRlZmF1bHRMZXZlbCBpbiBsYWJlbHMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGRlZmF1bHQgbGV2ZWw6JHtkZWZhdWx0TGV2ZWx9IG11c3QgYmUgaW5jbHVkZWQgaW4gY3VzdG9tIGxldmVsc2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMgKGxldmVscywgY3VzdG9tTGV2ZWxzKSB7XG4gIGNvbnN0IHsgbGFiZWxzLCB2YWx1ZXMgfSA9IGxldmVsc1xuICBmb3IgKGNvbnN0IGsgaW4gY3VzdG9tTGV2ZWxzKSB7XG4gICAgaWYgKGsgaW4gdmFsdWVzKSB7XG4gICAgICB0aHJvdyBFcnJvcignbGV2ZWxzIGNhbm5vdCBiZSBvdmVycmlkZGVuJylcbiAgICB9XG4gICAgaWYgKGN1c3RvbUxldmVsc1trXSBpbiBsYWJlbHMpIHtcbiAgICAgIHRocm93IEVycm9yKCdwcmUtZXhpc3RpbmcgbGV2ZWwgdmFsdWVzIGNhbm5vdCBiZSB1c2VkIGZvciBuZXcgbGV2ZWxzJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciBgbGV2ZWxDb21wYXJpc29uYCBpcyBjb3JyZWN0XG4gKlxuICogQHRocm93cyBFcnJvclxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSIHwgRnVuY3Rpb259IGxldmVsQ29tcGFyaXNvbiAtIHZhbHVlIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBhc3NlcnRMZXZlbENvbXBhcmlzb24gKGxldmVsQ29tcGFyaXNvbikge1xuICBpZiAodHlwZW9mIGxldmVsQ29tcGFyaXNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdzdHJpbmcnICYmIE9iamVjdC52YWx1ZXMoU09SVElOR19PUkRFUikuaW5jbHVkZXMobGV2ZWxDb21wYXJpc29uKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbHMgY29tcGFyaXNvbiBzaG91bGQgYmUgb25lIG9mIFwiQVNDXCIsIFwiREVTQ1wiIG9yIFwiZnVuY3Rpb25cIiB0eXBlJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXRpYWxMc0NhY2hlLFxuICBnZW5Mc0NhY2hlLFxuICBsZXZlbE1ldGhvZHMsXG4gIGdldExldmVsLFxuICBzZXRMZXZlbCxcbiAgaXNMZXZlbEVuYWJsZWQsXG4gIG1hcHBpbmdzLFxuICBhc3NlcnROb0xldmVsQ29sbGlzaW9ucyxcbiAgYXNzZXJ0RGVmYXVsdExldmVsRm91bmQsXG4gIGdlbkxldmVsQ29tcGFyaXNvbixcbiAgYXNzZXJ0TGV2ZWxDb21wYXJpc29uXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/levels.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/meta.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/meta.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = { version: '10.0.0' }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL21ldGEuanM/YWUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcxMC4wLjAnIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/meta.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/multistream.js":
/*!**********************************************!*\
  !*** ./node_modules/pino/lib/multistream.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst metadata = Symbol.for('pino.metadata')\nconst { DEFAULT_LEVELS } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/pino/lib/constants.js\")\n\nconst DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info\n\nfunction multistream (streamsArray, opts) {\n  streamsArray = streamsArray || []\n  opts = opts || { dedupe: false }\n\n  const streamLevels = Object.create(DEFAULT_LEVELS)\n  streamLevels.silent = Infinity\n  if (opts.levels && typeof opts.levels === 'object') {\n    Object.keys(opts.levels).forEach(i => {\n      streamLevels[i] = opts.levels[i]\n    })\n  }\n\n  const res = {\n    write,\n    add,\n    remove,\n    emit,\n    flushSync,\n    end,\n    minLevel: 0,\n    lastId: 0,\n    streams: [],\n    clone,\n    [metadata]: true,\n    streamLevels\n  }\n\n  if (Array.isArray(streamsArray)) {\n    streamsArray.forEach(add, res)\n  } else {\n    add.call(res, streamsArray)\n  }\n\n  // clean this object up\n  // or it will stay allocated forever\n  // as it is closed on the following closures\n  streamsArray = null\n\n  return res\n\n  // we can exit early because the streams are ordered by level\n  function write (data) {\n    let dest\n    const level = this.lastLevel\n    const { streams } = this\n    // for handling situation when several streams has the same level\n    let recordedLevel = 0\n    let stream\n\n    // if dedupe set to true we send logs to the stream with the highest level\n    // therefore, we have to change sorting order\n    for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {\n      dest = streams[i]\n      if (dest.level <= level) {\n        if (recordedLevel !== 0 && recordedLevel !== dest.level) {\n          break\n        }\n        stream = dest.stream\n        if (stream[metadata]) {\n          const { lastTime, lastMsg, lastObj, lastLogger } = this\n          stream.lastLevel = level\n          stream.lastTime = lastTime\n          stream.lastMsg = lastMsg\n          stream.lastObj = lastObj\n          stream.lastLogger = lastLogger\n        }\n        stream.write(data)\n        if (opts.dedupe) {\n          recordedLevel = dest.level\n        }\n      } else if (!opts.dedupe) {\n        break\n      }\n    }\n  }\n\n  function emit (...args) {\n    for (const { stream } of this.streams) {\n      if (typeof stream.emit === 'function') {\n        stream.emit(...args)\n      }\n    }\n  }\n\n  function flushSync () {\n    for (const { stream } of this.streams) {\n      if (typeof stream.flushSync === 'function') {\n        stream.flushSync()\n      }\n    }\n  }\n\n  function add (dest) {\n    if (!dest) {\n      return res\n    }\n\n    // Check that dest implements either StreamEntry or DestinationStream\n    const isStream = typeof dest.write === 'function' || dest.stream\n    const stream_ = dest.write ? dest : dest.stream\n    // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()\n    if (!isStream) {\n      throw Error('stream object needs to implement either StreamEntry or DestinationStream interface')\n    }\n\n    const { streams, streamLevels } = this\n\n    let level\n    if (typeof dest.levelVal === 'number') {\n      level = dest.levelVal\n    } else if (typeof dest.level === 'string') {\n      level = streamLevels[dest.level]\n    } else if (typeof dest.level === 'number') {\n      level = dest.level\n    } else {\n      level = DEFAULT_INFO_LEVEL\n    }\n\n    const dest_ = {\n      stream: stream_,\n      level,\n      levelVal: undefined,\n      id: ++res.lastId\n    }\n\n    streams.unshift(dest_)\n    streams.sort(compareByLevel)\n\n    this.minLevel = streams[0].level\n\n    return res\n  }\n\n  function remove (id) {\n    const { streams } = this\n    const index = streams.findIndex(s => s.id === id)\n\n    if (index >= 0) {\n      streams.splice(index, 1)\n      streams.sort(compareByLevel)\n      this.minLevel = streams.length > 0 ? streams[0].level : -1\n    }\n\n    return res\n  }\n\n  function end () {\n    for (const { stream } of this.streams) {\n      if (typeof stream.flushSync === 'function') {\n        stream.flushSync()\n      }\n      stream.end()\n    }\n  }\n\n  function clone (level) {\n    const streams = new Array(this.streams.length)\n\n    for (let i = 0; i < streams.length; i++) {\n      streams[i] = {\n        level,\n        stream: this.streams[i].stream\n      }\n    }\n\n    return {\n      write,\n      add,\n      remove,\n      minLevel: level,\n      streams,\n      clone,\n      emit,\n      flushSync,\n      [metadata]: true\n    }\n  }\n}\n\nfunction compareByLevel (a, b) {\n  return a.level - b.level\n}\n\nfunction initLoopVar (length, dedupe) {\n  return dedupe ? length - 1 : 0\n}\n\nfunction adjustLoopVar (i, dedupe) {\n  return dedupe ? i - 1 : i + 1\n}\n\nfunction checkLoopVar (i, length, dedupe) {\n  return dedupe ? i >= 0 : i < length\n}\n\nmodule.exports = multistream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbXVsdGlzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsK0RBQWE7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQsOENBQThDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksd0JBQXdCOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL211bHRpc3RyZWFtLmpzP2I3NzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1ldGFkYXRhID0gU3ltYm9sLmZvcigncGluby5tZXRhZGF0YScpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IERFRkFVTFRfSU5GT19MRVZFTCA9IERFRkFVTFRfTEVWRUxTLmluZm9cblxuZnVuY3Rpb24gbXVsdGlzdHJlYW0gKHN0cmVhbXNBcnJheSwgb3B0cykge1xuICBzdHJlYW1zQXJyYXkgPSBzdHJlYW1zQXJyYXkgfHwgW11cbiAgb3B0cyA9IG9wdHMgfHwgeyBkZWR1cGU6IGZhbHNlIH1cblxuICBjb25zdCBzdHJlYW1MZXZlbHMgPSBPYmplY3QuY3JlYXRlKERFRkFVTFRfTEVWRUxTKVxuICBzdHJlYW1MZXZlbHMuc2lsZW50ID0gSW5maW5pdHlcbiAgaWYgKG9wdHMubGV2ZWxzICYmIHR5cGVvZiBvcHRzLmxldmVscyA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyhvcHRzLmxldmVscykuZm9yRWFjaChpID0+IHtcbiAgICAgIHN0cmVhbUxldmVsc1tpXSA9IG9wdHMubGV2ZWxzW2ldXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IHtcbiAgICB3cml0ZSxcbiAgICBhZGQsXG4gICAgcmVtb3ZlLFxuICAgIGVtaXQsXG4gICAgZmx1c2hTeW5jLFxuICAgIGVuZCxcbiAgICBtaW5MZXZlbDogMCxcbiAgICBsYXN0SWQ6IDAsXG4gICAgc3RyZWFtczogW10sXG4gICAgY2xvbmUsXG4gICAgW21ldGFkYXRhXTogdHJ1ZSxcbiAgICBzdHJlYW1MZXZlbHNcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNBcnJheSkpIHtcbiAgICBzdHJlYW1zQXJyYXkuZm9yRWFjaChhZGQsIHJlcylcbiAgfSBlbHNlIHtcbiAgICBhZGQuY2FsbChyZXMsIHN0cmVhbXNBcnJheSlcbiAgfVxuXG4gIC8vIGNsZWFuIHRoaXMgb2JqZWN0IHVwXG4gIC8vIG9yIGl0IHdpbGwgc3RheSBhbGxvY2F0ZWQgZm9yZXZlclxuICAvLyBhcyBpdCBpcyBjbG9zZWQgb24gdGhlIGZvbGxvd2luZyBjbG9zdXJlc1xuICBzdHJlYW1zQXJyYXkgPSBudWxsXG5cbiAgcmV0dXJuIHJlc1xuXG4gIC8vIHdlIGNhbiBleGl0IGVhcmx5IGJlY2F1c2UgdGhlIHN0cmVhbXMgYXJlIG9yZGVyZWQgYnkgbGV2ZWxcbiAgZnVuY3Rpb24gd3JpdGUgKGRhdGEpIHtcbiAgICBsZXQgZGVzdFxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5sYXN0TGV2ZWxcbiAgICBjb25zdCB7IHN0cmVhbXMgfSA9IHRoaXNcbiAgICAvLyBmb3IgaGFuZGxpbmcgc2l0dWF0aW9uIHdoZW4gc2V2ZXJhbCBzdHJlYW1zIGhhcyB0aGUgc2FtZSBsZXZlbFxuICAgIGxldCByZWNvcmRlZExldmVsID0gMFxuICAgIGxldCBzdHJlYW1cblxuICAgIC8vIGlmIGRlZHVwZSBzZXQgdG8gdHJ1ZSB3ZSBzZW5kIGxvZ3MgdG8gdGhlIHN0cmVhbSB3aXRoIHRoZSBoaWdoZXN0IGxldmVsXG4gICAgLy8gdGhlcmVmb3JlLCB3ZSBoYXZlIHRvIGNoYW5nZSBzb3J0aW5nIG9yZGVyXG4gICAgZm9yIChsZXQgaSA9IGluaXRMb29wVmFyKHN0cmVhbXMubGVuZ3RoLCBvcHRzLmRlZHVwZSk7IGNoZWNrTG9vcFZhcihpLCBzdHJlYW1zLmxlbmd0aCwgb3B0cy5kZWR1cGUpOyBpID0gYWRqdXN0TG9vcFZhcihpLCBvcHRzLmRlZHVwZSkpIHtcbiAgICAgIGRlc3QgPSBzdHJlYW1zW2ldXG4gICAgICBpZiAoZGVzdC5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICBpZiAocmVjb3JkZWRMZXZlbCAhPT0gMCAmJiByZWNvcmRlZExldmVsICE9PSBkZXN0LmxldmVsKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSBkZXN0LnN0cmVhbVxuICAgICAgICBpZiAoc3RyZWFtW21ldGFkYXRhXSkge1xuICAgICAgICAgIGNvbnN0IHsgbGFzdFRpbWUsIGxhc3RNc2csIGxhc3RPYmosIGxhc3RMb2dnZXIgfSA9IHRoaXNcbiAgICAgICAgICBzdHJlYW0ubGFzdExldmVsID0gbGV2ZWxcbiAgICAgICAgICBzdHJlYW0ubGFzdFRpbWUgPSBsYXN0VGltZVxuICAgICAgICAgIHN0cmVhbS5sYXN0TXNnID0gbGFzdE1zZ1xuICAgICAgICAgIHN0cmVhbS5sYXN0T2JqID0gbGFzdE9ialxuICAgICAgICAgIHN0cmVhbS5sYXN0TG9nZ2VyID0gbGFzdExvZ2dlclxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS53cml0ZShkYXRhKVxuICAgICAgICBpZiAob3B0cy5kZWR1cGUpIHtcbiAgICAgICAgICByZWNvcmRlZExldmVsID0gZGVzdC5sZXZlbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFvcHRzLmRlZHVwZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXQgKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IHsgc3RyZWFtIH0gb2YgdGhpcy5zdHJlYW1zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KC4uLmFyZ3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hTeW5jICgpIHtcbiAgICBmb3IgKGNvbnN0IHsgc3RyZWFtIH0gb2YgdGhpcy5zdHJlYW1zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5mbHVzaFN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkIChkZXN0KSB7XG4gICAgaWYgKCFkZXN0KSB7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCBkZXN0IGltcGxlbWVudHMgZWl0aGVyIFN0cmVhbUVudHJ5IG9yIERlc3RpbmF0aW9uU3RyZWFtXG4gICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgZGVzdC53cml0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBkZXN0LnN0cmVhbVxuICAgIGNvbnN0IHN0cmVhbV8gPSBkZXN0LndyaXRlID8gZGVzdCA6IGRlc3Quc3RyZWFtXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gcHJvdmlkZSBhIG1lYW5pbmdmdWwgZXJyb3IgbWVzc2FnZSwgb3RoZXJ3aXNlIGl0IHRocm93cyBzb21ld2hlcmUgaW5zaWRlIHdyaXRlKClcbiAgICBpZiAoIWlzU3RyZWFtKSB7XG4gICAgICB0aHJvdyBFcnJvcignc3RyZWFtIG9iamVjdCBuZWVkcyB0byBpbXBsZW1lbnQgZWl0aGVyIFN0cmVhbUVudHJ5IG9yIERlc3RpbmF0aW9uU3RyZWFtIGludGVyZmFjZScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzdHJlYW1zLCBzdHJlYW1MZXZlbHMgfSA9IHRoaXNcblxuICAgIGxldCBsZXZlbFxuICAgIGlmICh0eXBlb2YgZGVzdC5sZXZlbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxldmVsID0gZGVzdC5sZXZlbFZhbFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3QubGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXZlbCA9IHN0cmVhbUxldmVsc1tkZXN0LmxldmVsXVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3QubGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICBsZXZlbCA9IGRlc3QubGV2ZWxcbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwgPSBERUZBVUxUX0lORk9fTEVWRUxcbiAgICB9XG5cbiAgICBjb25zdCBkZXN0XyA9IHtcbiAgICAgIHN0cmVhbTogc3RyZWFtXyxcbiAgICAgIGxldmVsLFxuICAgICAgbGV2ZWxWYWw6IHVuZGVmaW5lZCxcbiAgICAgIGlkOiArK3Jlcy5sYXN0SWRcbiAgICB9XG5cbiAgICBzdHJlYW1zLnVuc2hpZnQoZGVzdF8pXG4gICAgc3RyZWFtcy5zb3J0KGNvbXBhcmVCeUxldmVsKVxuXG4gICAgdGhpcy5taW5MZXZlbCA9IHN0cmVhbXNbMF0ubGV2ZWxcblxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSAoaWQpIHtcbiAgICBjb25zdCB7IHN0cmVhbXMgfSA9IHRoaXNcbiAgICBjb25zdCBpbmRleCA9IHN0cmVhbXMuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gaWQpXG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgc3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICBzdHJlYW1zLnNvcnQoY29tcGFyZUJ5TGV2ZWwpXG4gICAgICB0aGlzLm1pbkxldmVsID0gc3RyZWFtcy5sZW5ndGggPiAwID8gc3RyZWFtc1swXS5sZXZlbCA6IC0xXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICBmb3IgKGNvbnN0IHsgc3RyZWFtIH0gb2YgdGhpcy5zdHJlYW1zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5mbHVzaFN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgICB9XG4gICAgICBzdHJlYW0uZW5kKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZSAobGV2ZWwpIHtcbiAgICBjb25zdCBzdHJlYW1zID0gbmV3IEFycmF5KHRoaXMuc3RyZWFtcy5sZW5ndGgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0cmVhbXNbaV0gPSB7XG4gICAgICAgIGxldmVsLFxuICAgICAgICBzdHJlYW06IHRoaXMuc3RyZWFtc1tpXS5zdHJlYW1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGUsXG4gICAgICBhZGQsXG4gICAgICByZW1vdmUsXG4gICAgICBtaW5MZXZlbDogbGV2ZWwsXG4gICAgICBzdHJlYW1zLFxuICAgICAgY2xvbmUsXG4gICAgICBlbWl0LFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgW21ldGFkYXRhXTogdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlQnlMZXZlbCAoYSwgYikge1xuICByZXR1cm4gYS5sZXZlbCAtIGIubGV2ZWxcbn1cblxuZnVuY3Rpb24gaW5pdExvb3BWYXIgKGxlbmd0aCwgZGVkdXBlKSB7XG4gIHJldHVybiBkZWR1cGUgPyBsZW5ndGggLSAxIDogMFxufVxuXG5mdW5jdGlvbiBhZGp1c3RMb29wVmFyIChpLCBkZWR1cGUpIHtcbiAgcmV0dXJuIGRlZHVwZSA/IGkgLSAxIDogaSArIDFcbn1cblxuZnVuY3Rpb24gY2hlY2tMb29wVmFyIChpLCBsZW5ndGgsIGRlZHVwZSkge1xuICByZXR1cm4gZGVkdXBlID8gaSA+PSAwIDogaSA8IGxlbmd0aFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bHRpc3RyZWFtXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/multistream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/proto.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/proto.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst { EventEmitter } = __webpack_require__(/*! node:events */ \"node:events\")\nconst {\n  lsCacheSym,\n  levelValSym,\n  setLevelSym,\n  getLevelSym,\n  chindingsSym,\n  parsedChindingsSym,\n  mixinSym,\n  asJsonSym,\n  writeSym,\n  mixinMergeStrategySym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  serializersSym,\n  formattersSym,\n  errorKeySym,\n  messageKeySym,\n  useOnlyCustomLevelsSym,\n  needsMetadataGsym,\n  redactFmtSym,\n  stringifySym,\n  formatOptsSym,\n  stringifiersSym,\n  msgPrefixSym,\n  hooksSym\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst {\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  initialLsCache,\n  genLsCache,\n  assertNoLevelCollisions\n} = __webpack_require__(/*! ./levels */ \"(ssr)/./node_modules/pino/lib/levels.js\")\nconst {\n  asChindings,\n  asJson,\n  buildFormatters,\n  stringify,\n  noop\n} = __webpack_require__(/*! ./tools */ \"(ssr)/./node_modules/pino/lib/tools.js\")\nconst {\n  version\n} = __webpack_require__(/*! ./meta */ \"(ssr)/./node_modules/pino/lib/meta.js\")\nconst redaction = __webpack_require__(/*! ./redaction */ \"(ssr)/./node_modules/pino/lib/redaction.js\")\n\n// note: use of class is satirical\n// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127\nconst constructor = class Pino {}\nconst prototype = {\n  constructor,\n  child,\n  bindings,\n  setBindings,\n  flush,\n  isLevelEnabled,\n  version,\n  get level () { return this[getLevelSym]() },\n  set level (lvl) { this[setLevelSym](lvl) },\n  get levelVal () { return this[levelValSym] },\n  set levelVal (n) { throw Error('levelVal is read-only') },\n  get msgPrefix () { return this[msgPrefixSym] },\n  get [Symbol.toStringTag] () { return 'Pino' },\n  [lsCacheSym]: initialLsCache,\n  [writeSym]: write,\n  [asJsonSym]: asJson,\n  [getLevelSym]: getLevel,\n  [setLevelSym]: setLevel\n}\n\nObject.setPrototypeOf(prototype, EventEmitter.prototype)\n\n// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing\nmodule.exports = function () {\n  return Object.create(prototype)\n}\n\nconst resetChildingsFormatter = bindings => bindings\nfunction child (bindings, options) {\n  if (!bindings) {\n    throw Error('missing bindings for child Pino')\n  }\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const instance = Object.create(this)\n\n  // If an `options` object was not supplied, we can improve\n  // the performance of child creation by skipping\n  // the checks for set options and simply return\n  // a baseline instance.\n  if (options == null) {\n    if (instance[formattersSym].bindings !== resetChildingsFormatter) {\n      instance[formattersSym] = buildFormatters(\n        formatters.level,\n        resetChildingsFormatter,\n        formatters.log\n      )\n    }\n\n    instance[chindingsSym] = asChindings(instance, bindings)\n\n    if (this.onChild !== noop) {\n      this.onChild(instance)\n    }\n\n    return instance\n  }\n\n  if (options.hasOwnProperty('serializers') === true) {\n    instance[serializersSym] = Object.create(null)\n\n    for (const k in serializers) {\n      instance[serializersSym][k] = serializers[k]\n    }\n    const parentSymbols = Object.getOwnPropertySymbols(serializers)\n    /* eslint no-var: off */\n    for (var i = 0; i < parentSymbols.length; i++) {\n      const ks = parentSymbols[i]\n      instance[serializersSym][ks] = serializers[ks]\n    }\n\n    for (const bk in options.serializers) {\n      instance[serializersSym][bk] = options.serializers[bk]\n    }\n    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers)\n    for (var bi = 0; bi < bindingsSymbols.length; bi++) {\n      const bks = bindingsSymbols[bi]\n      instance[serializersSym][bks] = options.serializers[bks]\n    }\n  } else instance[serializersSym] = serializers\n  if (options.hasOwnProperty('formatters')) {\n    const { level, bindings: chindings, log } = options.formatters\n    instance[formattersSym] = buildFormatters(\n      level || formatters.level,\n      chindings || resetChildingsFormatter,\n      log || formatters.log\n    )\n  } else {\n    instance[formattersSym] = buildFormatters(\n      formatters.level,\n      resetChildingsFormatter,\n      formatters.log\n    )\n  }\n  if (options.hasOwnProperty('customLevels') === true) {\n    assertNoLevelCollisions(this.levels, options.customLevels)\n    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym])\n    genLsCache(instance)\n  }\n\n  // redact must place before asChindings and only replace if exist\n  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {\n    instance.redact = options.redact // replace redact directly\n    const stringifiers = redaction(instance.redact, stringify)\n    const formatOpts = { stringify: stringifiers[redactFmtSym] }\n    instance[stringifySym] = stringify\n    instance[stringifiersSym] = stringifiers\n    instance[formatOptsSym] = formatOpts\n  }\n\n  if (typeof options.msgPrefix === 'string') {\n    instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix\n  }\n\n  instance[chindingsSym] = asChindings(instance, bindings)\n  if ((options.level !== undefined && options.level !== this.level) || options.hasOwnProperty('customLevels')) {\n    const childLevel = options.level || this.level\n    instance[setLevelSym](childLevel)\n  }\n  this.onChild(instance)\n  return instance\n}\n\nfunction bindings () {\n  const chindings = this[chindingsSym]\n  const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,\"pid\":7068,\"hostname\":\"myMac\"\n  const bindingsFromJson = JSON.parse(chindingsJson)\n  delete bindingsFromJson.pid\n  delete bindingsFromJson.hostname\n  return bindingsFromJson\n}\n\nfunction setBindings (newBindings) {\n  const chindings = asChindings(this, newBindings)\n  this[chindingsSym] = chindings\n  delete this[parsedChindingsSym]\n}\n\n/**\n * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.\n * Fields from `mergeObject` have higher priority in this strategy.\n *\n * @param {Object} mergeObject The object a user has supplied to the logging function.\n * @param {Object} mixinObject The result of the `mixin` method.\n * @return {Object}\n */\nfunction defaultMixinMergeStrategy (mergeObject, mixinObject) {\n  return Object.assign(mixinObject, mergeObject)\n}\n\nfunction write (_obj, msg, num) {\n  const t = this[timeSym]()\n  const mixin = this[mixinSym]\n  const errorKey = this[errorKeySym]\n  const messageKey = this[messageKeySym]\n  const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy\n  let obj\n  const streamWriteHook = this[hooksSym].streamWrite\n\n  if (_obj === undefined || _obj === null) {\n    obj = {}\n  } else if (_obj instanceof Error) {\n    obj = { [errorKey]: _obj }\n    if (msg === undefined) {\n      msg = _obj.message\n    }\n  } else {\n    obj = _obj\n    if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {\n      msg = _obj[errorKey].message\n    }\n  }\n\n  if (mixin) {\n    obj = mixinMergeStrategy(obj, mixin(obj, num, this))\n  }\n\n  const s = this[asJsonSym](obj, msg, num, t)\n\n  const stream = this[streamSym]\n  if (stream[needsMetadataGsym] === true) {\n    stream.lastLevel = num\n    stream.lastObj = obj\n    stream.lastMsg = msg\n    stream.lastTime = t.slice(this[timeSliceIndexSym])\n    stream.lastLogger = this // for child loggers\n  }\n  stream.write(streamWriteHook ? streamWriteHook(s) : s)\n}\n\nfunction flush (cb) {\n  if (cb != null && typeof cb !== 'function') {\n    throw Error('callback must be a function')\n  }\n\n  const stream = this[streamSym]\n\n  if (typeof stream.flush === 'function') {\n    stream.flush(cb || noop)\n  } else if (cb) cb()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcHJvdG8uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVEQUFTO0FBQ3JCO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxxREFBUTtBQUNwQixrQkFBa0IsbUJBQU8sQ0FBQywrREFBYTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0Msb0JBQW9CLHdCQUF3QjtBQUM1QyxvQkFBb0IsMEJBQTBCO0FBQzlDLHFCQUFxQixzQ0FBc0M7QUFDM0QscUJBQXFCLDJCQUEyQjtBQUNoRCxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUUscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3Byb3RvLmpzP2JkYjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cblxuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IHtcbiAgbHNDYWNoZVN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIHNldExldmVsU3ltLFxuICBnZXRMZXZlbFN5bSxcbiAgY2hpbmRpbmdzU3ltLFxuICBwYXJzZWRDaGluZGluZ3NTeW0sXG4gIG1peGluU3ltLFxuICBhc0pzb25TeW0sXG4gIHdyaXRlU3ltLFxuICBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0sXG4gIHRpbWVTeW0sXG4gIHRpbWVTbGljZUluZGV4U3ltLFxuICBzdHJlYW1TeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBlcnJvcktleVN5bSxcbiAgbWVzc2FnZUtleVN5bSxcbiAgdXNlT25seUN1c3RvbUxldmVsc1N5bSxcbiAgbmVlZHNNZXRhZGF0YUdzeW0sXG4gIHJlZGFjdEZtdFN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIG1zZ1ByZWZpeFN5bSxcbiAgaG9va3NTeW1cbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3Qge1xuICBnZXRMZXZlbCxcbiAgc2V0TGV2ZWwsXG4gIGlzTGV2ZWxFbmFibGVkLFxuICBtYXBwaW5ncyxcbiAgaW5pdGlhbExzQ2FjaGUsXG4gIGdlbkxzQ2FjaGUsXG4gIGFzc2VydE5vTGV2ZWxDb2xsaXNpb25zXG59ID0gcmVxdWlyZSgnLi9sZXZlbHMnKVxuY29uc3Qge1xuICBhc0NoaW5kaW5ncyxcbiAgYXNKc29uLFxuICBidWlsZEZvcm1hdHRlcnMsXG4gIHN0cmluZ2lmeSxcbiAgbm9vcFxufSA9IHJlcXVpcmUoJy4vdG9vbHMnKVxuY29uc3Qge1xuICB2ZXJzaW9uXG59ID0gcmVxdWlyZSgnLi9tZXRhJylcbmNvbnN0IHJlZGFjdGlvbiA9IHJlcXVpcmUoJy4vcmVkYWN0aW9uJylcblxuLy8gbm90ZTogdXNlIG9mIGNsYXNzIGlzIHNhdGlyaWNhbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL3B1bGwvNDMzI3B1bGxyZXF1ZXN0cmV2aWV3LTEyNzcwMzEyN1xuY29uc3QgY29uc3RydWN0b3IgPSBjbGFzcyBQaW5vIHt9XG5jb25zdCBwcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yLFxuICBjaGlsZCxcbiAgYmluZGluZ3MsXG4gIHNldEJpbmRpbmdzLFxuICBmbHVzaCxcbiAgaXNMZXZlbEVuYWJsZWQsXG4gIHZlcnNpb24sXG4gIGdldCBsZXZlbCAoKSB7IHJldHVybiB0aGlzW2dldExldmVsU3ltXSgpIH0sXG4gIHNldCBsZXZlbCAobHZsKSB7IHRoaXNbc2V0TGV2ZWxTeW1dKGx2bCkgfSxcbiAgZ2V0IGxldmVsVmFsICgpIHsgcmV0dXJuIHRoaXNbbGV2ZWxWYWxTeW1dIH0sXG4gIHNldCBsZXZlbFZhbCAobikgeyB0aHJvdyBFcnJvcignbGV2ZWxWYWwgaXMgcmVhZC1vbmx5JykgfSxcbiAgZ2V0IG1zZ1ByZWZpeCAoKSB7IHJldHVybiB0aGlzW21zZ1ByZWZpeFN5bV0gfSxcbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHsgcmV0dXJuICdQaW5vJyB9LFxuICBbbHNDYWNoZVN5bV06IGluaXRpYWxMc0NhY2hlLFxuICBbd3JpdGVTeW1dOiB3cml0ZSxcbiAgW2FzSnNvblN5bV06IGFzSnNvbixcbiAgW2dldExldmVsU3ltXTogZ2V0TGV2ZWwsXG4gIFtzZXRMZXZlbFN5bV06IHNldExldmVsXG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbi8vIGV4cG9ydGluZyBhbmQgY29uc3VtaW5nIHRoZSBwcm90b3R5cGUgb2JqZWN0IHVzaW5nIGZhY3RvcnkgcGF0dGVybiBmaXhlcyBzY29waW5nIGlzc3VlcyB3aXRoIGdldHRlcnMgd2hlbiBzZXJpYWxpemluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSlcbn1cblxuY29uc3QgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIgPSBiaW5kaW5ncyA9PiBiaW5kaW5nc1xuZnVuY3Rpb24gY2hpbGQgKGJpbmRpbmdzLCBvcHRpb25zKSB7XG4gIGlmICghYmluZGluZ3MpIHtcbiAgICB0aHJvdyBFcnJvcignbWlzc2luZyBiaW5kaW5ncyBmb3IgY2hpbGQgUGlubycpXG4gIH1cbiAgY29uc3Qgc2VyaWFsaXplcnMgPSB0aGlzW3NlcmlhbGl6ZXJzU3ltXVxuICBjb25zdCBmb3JtYXR0ZXJzID0gdGhpc1tmb3JtYXR0ZXJzU3ltXVxuICBjb25zdCBpbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUodGhpcylcblxuICAvLyBJZiBhbiBgb3B0aW9uc2Agb2JqZWN0IHdhcyBub3Qgc3VwcGxpZWQsIHdlIGNhbiBpbXByb3ZlXG4gIC8vIHRoZSBwZXJmb3JtYW5jZSBvZiBjaGlsZCBjcmVhdGlvbiBieSBza2lwcGluZ1xuICAvLyB0aGUgY2hlY2tzIGZvciBzZXQgb3B0aW9ucyBhbmQgc2ltcGx5IHJldHVyblxuICAvLyBhIGJhc2VsaW5lIGluc3RhbmNlLlxuICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgaWYgKGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dLmJpbmRpbmdzICE9PSByZXNldENoaWxkaW5nc0Zvcm1hdHRlcikge1xuICAgICAgaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0gPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgICAgIGZvcm1hdHRlcnMubGV2ZWwsXG4gICAgICAgIHJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyLFxuICAgICAgICBmb3JtYXR0ZXJzLmxvZ1xuICAgICAgKVxuICAgIH1cblxuICAgIGluc3RhbmNlW2NoaW5kaW5nc1N5bV0gPSBhc0NoaW5kaW5ncyhpbnN0YW5jZSwgYmluZGluZ3MpXG5cbiAgICBpZiAodGhpcy5vbkNoaWxkICE9PSBub29wKSB7XG4gICAgICB0aGlzLm9uQ2hpbGQoaW5zdGFuY2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlXG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2VyaWFsaXplcnMnKSA9PT0gdHJ1ZSkge1xuICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAoY29uc3QgayBpbiBzZXJpYWxpemVycykge1xuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2tdID0gc2VyaWFsaXplcnNba11cbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc2VyaWFsaXplcnMpXG4gICAgLyogZXNsaW50IG5vLXZhcjogb2ZmICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrcyA9IHBhcmVudFN5bWJvbHNbaV1cbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtrc10gPSBzZXJpYWxpemVyc1trc11cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGJrIGluIG9wdGlvbnMuc2VyaWFsaXplcnMpIHtcbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtia10gPSBvcHRpb25zLnNlcmlhbGl6ZXJzW2JrXVxuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nc1N5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9wdGlvbnMuc2VyaWFsaXplcnMpXG4gICAgZm9yICh2YXIgYmkgPSAwOyBiaSA8IGJpbmRpbmdzU3ltYm9scy5sZW5ndGg7IGJpKyspIHtcbiAgICAgIGNvbnN0IGJrcyA9IGJpbmRpbmdzU3ltYm9sc1tiaV1cbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtia3NdID0gb3B0aW9ucy5zZXJpYWxpemVyc1tia3NdXG4gICAgfVxuICB9IGVsc2UgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dID0gc2VyaWFsaXplcnNcbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Zvcm1hdHRlcnMnKSkge1xuICAgIGNvbnN0IHsgbGV2ZWwsIGJpbmRpbmdzOiBjaGluZGluZ3MsIGxvZyB9ID0gb3B0aW9ucy5mb3JtYXR0ZXJzXG4gICAgaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0gPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgICBsZXZlbCB8fCBmb3JtYXR0ZXJzLmxldmVsLFxuICAgICAgY2hpbmRpbmdzIHx8IHJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyLFxuICAgICAgbG9nIHx8IGZvcm1hdHRlcnMubG9nXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dID0gYnVpbGRGb3JtYXR0ZXJzKFxuICAgICAgZm9ybWF0dGVycy5sZXZlbCxcbiAgICAgIHJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyLFxuICAgICAgZm9ybWF0dGVycy5sb2dcbiAgICApXG4gIH1cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2N1c3RvbUxldmVscycpID09PSB0cnVlKSB7XG4gICAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnModGhpcy5sZXZlbHMsIG9wdGlvbnMuY3VzdG9tTGV2ZWxzKVxuICAgIGluc3RhbmNlLmxldmVscyA9IG1hcHBpbmdzKG9wdGlvbnMuY3VzdG9tTGV2ZWxzLCBpbnN0YW5jZVt1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXSlcbiAgICBnZW5Mc0NhY2hlKGluc3RhbmNlKVxuICB9XG5cbiAgLy8gcmVkYWN0IG11c3QgcGxhY2UgYmVmb3JlIGFzQ2hpbmRpbmdzIGFuZCBvbmx5IHJlcGxhY2UgaWYgZXhpc3RcbiAgaWYgKCh0eXBlb2Ygb3B0aW9ucy5yZWRhY3QgPT09ICdvYmplY3QnICYmIG9wdGlvbnMucmVkYWN0ICE9PSBudWxsKSB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMucmVkYWN0KSkge1xuICAgIGluc3RhbmNlLnJlZGFjdCA9IG9wdGlvbnMucmVkYWN0IC8vIHJlcGxhY2UgcmVkYWN0IGRpcmVjdGx5XG4gICAgY29uc3Qgc3RyaW5naWZpZXJzID0gcmVkYWN0aW9uKGluc3RhbmNlLnJlZGFjdCwgc3RyaW5naWZ5KVxuICAgIGNvbnN0IGZvcm1hdE9wdHMgPSB7IHN0cmluZ2lmeTogc3RyaW5naWZpZXJzW3JlZGFjdEZtdFN5bV0gfVxuICAgIGluc3RhbmNlW3N0cmluZ2lmeVN5bV0gPSBzdHJpbmdpZnlcbiAgICBpbnN0YW5jZVtzdHJpbmdpZmllcnNTeW1dID0gc3RyaW5naWZpZXJzXG4gICAgaW5zdGFuY2VbZm9ybWF0T3B0c1N5bV0gPSBmb3JtYXRPcHRzXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMubXNnUHJlZml4ID09PSAnc3RyaW5nJykge1xuICAgIGluc3RhbmNlW21zZ1ByZWZpeFN5bV0gPSAodGhpc1ttc2dQcmVmaXhTeW1dIHx8ICcnKSArIG9wdGlvbnMubXNnUHJlZml4XG4gIH1cblxuICBpbnN0YW5jZVtjaGluZGluZ3NTeW1dID0gYXNDaGluZGluZ3MoaW5zdGFuY2UsIGJpbmRpbmdzKVxuICBpZiAoKG9wdGlvbnMubGV2ZWwgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmxldmVsICE9PSB0aGlzLmxldmVsKSB8fCBvcHRpb25zLmhhc093blByb3BlcnR5KCdjdXN0b21MZXZlbHMnKSkge1xuICAgIGNvbnN0IGNoaWxkTGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IHRoaXMubGV2ZWxcbiAgICBpbnN0YW5jZVtzZXRMZXZlbFN5bV0oY2hpbGRMZXZlbClcbiAgfVxuICB0aGlzLm9uQ2hpbGQoaW5zdGFuY2UpXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBiaW5kaW5ncyAoKSB7XG4gIGNvbnN0IGNoaW5kaW5ncyA9IHRoaXNbY2hpbmRpbmdzU3ltXVxuICBjb25zdCBjaGluZGluZ3NKc29uID0gYHske2NoaW5kaW5ncy5zdWJzdHIoMSl9fWAgLy8gYXQgbGVhc3QgY29udGFpbnMgLFwicGlkXCI6NzA2OCxcImhvc3RuYW1lXCI6XCJteU1hY1wiXG4gIGNvbnN0IGJpbmRpbmdzRnJvbUpzb24gPSBKU09OLnBhcnNlKGNoaW5kaW5nc0pzb24pXG4gIGRlbGV0ZSBiaW5kaW5nc0Zyb21Kc29uLnBpZFxuICBkZWxldGUgYmluZGluZ3NGcm9tSnNvbi5ob3N0bmFtZVxuICByZXR1cm4gYmluZGluZ3NGcm9tSnNvblxufVxuXG5mdW5jdGlvbiBzZXRCaW5kaW5ncyAobmV3QmluZGluZ3MpIHtcbiAgY29uc3QgY2hpbmRpbmdzID0gYXNDaGluZGluZ3ModGhpcywgbmV3QmluZGluZ3MpXG4gIHRoaXNbY2hpbmRpbmdzU3ltXSA9IGNoaW5kaW5nc1xuICBkZWxldGUgdGhpc1twYXJzZWRDaGluZGluZ3NTeW1dXG59XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneSBmb3IgY3JlYXRpbmcgYG1lcmdlT2JqZWN0YCBmcm9tIGFyZ3VtZW50cyBhbmQgdGhlIHJlc3VsdCBmcm9tIGBtaXhpbigpYC5cbiAqIEZpZWxkcyBmcm9tIGBtZXJnZU9iamVjdGAgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgaW4gdGhpcyBzdHJhdGVneS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWVyZ2VPYmplY3QgVGhlIG9iamVjdCBhIHVzZXIgaGFzIHN1cHBsaWVkIHRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG1peGluT2JqZWN0IFRoZSByZXN1bHQgb2YgdGhlIGBtaXhpbmAgbWV0aG9kLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZWZhdWx0TWl4aW5NZXJnZVN0cmF0ZWd5IChtZXJnZU9iamVjdCwgbWl4aW5PYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWl4aW5PYmplY3QsIG1lcmdlT2JqZWN0KVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoX29iaiwgbXNnLCBudW0pIHtcbiAgY29uc3QgdCA9IHRoaXNbdGltZVN5bV0oKVxuICBjb25zdCBtaXhpbiA9IHRoaXNbbWl4aW5TeW1dXG4gIGNvbnN0IGVycm9yS2V5ID0gdGhpc1tlcnJvcktleVN5bV1cbiAgY29uc3QgbWVzc2FnZUtleSA9IHRoaXNbbWVzc2FnZUtleVN5bV1cbiAgY29uc3QgbWl4aW5NZXJnZVN0cmF0ZWd5ID0gdGhpc1ttaXhpbk1lcmdlU3RyYXRlZ3lTeW1dIHx8IGRlZmF1bHRNaXhpbk1lcmdlU3RyYXRlZ3lcbiAgbGV0IG9ialxuICBjb25zdCBzdHJlYW1Xcml0ZUhvb2sgPSB0aGlzW2hvb2tzU3ltXS5zdHJlYW1Xcml0ZVxuXG4gIGlmIChfb2JqID09PSB1bmRlZmluZWQgfHwgX29iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHt9XG4gIH0gZWxzZSBpZiAoX29iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgb2JqID0geyBbZXJyb3JLZXldOiBfb2JqIH1cbiAgICBpZiAobXNnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1zZyA9IF9vYmoubWVzc2FnZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvYmogPSBfb2JqXG4gICAgaWYgKG1zZyA9PT0gdW5kZWZpbmVkICYmIF9vYmpbbWVzc2FnZUtleV0gPT09IHVuZGVmaW5lZCAmJiBfb2JqW2Vycm9yS2V5XSkge1xuICAgICAgbXNnID0gX29ialtlcnJvcktleV0ubWVzc2FnZVxuICAgIH1cbiAgfVxuXG4gIGlmIChtaXhpbikge1xuICAgIG9iaiA9IG1peGluTWVyZ2VTdHJhdGVneShvYmosIG1peGluKG9iaiwgbnVtLCB0aGlzKSlcbiAgfVxuXG4gIGNvbnN0IHMgPSB0aGlzW2FzSnNvblN5bV0ob2JqLCBtc2csIG51bSwgdClcblxuICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cbiAgaWYgKHN0cmVhbVtuZWVkc01ldGFkYXRhR3N5bV0gPT09IHRydWUpIHtcbiAgICBzdHJlYW0ubGFzdExldmVsID0gbnVtXG4gICAgc3RyZWFtLmxhc3RPYmogPSBvYmpcbiAgICBzdHJlYW0ubGFzdE1zZyA9IG1zZ1xuICAgIHN0cmVhbS5sYXN0VGltZSA9IHQuc2xpY2UodGhpc1t0aW1lU2xpY2VJbmRleFN5bV0pXG4gICAgc3RyZWFtLmxhc3RMb2dnZXIgPSB0aGlzIC8vIGZvciBjaGlsZCBsb2dnZXJzXG4gIH1cbiAgc3RyZWFtLndyaXRlKHN0cmVhbVdyaXRlSG9vayA/IHN0cmVhbVdyaXRlSG9vayhzKSA6IHMpXG59XG5cbmZ1bmN0aW9uIGZsdXNoIChjYikge1xuICBpZiAoY2IgIT0gbnVsbCAmJiB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IHRoaXNbc3RyZWFtU3ltXVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtLmZsdXNoKGNiIHx8IG5vb3ApXG4gIH0gZWxzZSBpZiAoY2IpIGNiKClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/proto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/redaction.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/redaction.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst slowRedact = __webpack_require__(/*! slow-redact */ \"(ssr)/./node_modules/slow-redact/index.js\")\nconst { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\n\n// Custom rx regex equivalent to fast-redact's rx\nconst rx = /[^.[\\]]+|\\[([^[\\]]*?)\\]/g\n\nconst CENSOR = '[Redacted]'\nconst strict = false // TODO should this be configurable?\n\nfunction redaction (opts, serialize) {\n  const { paths, censor, remove } = handle(opts)\n\n  const shape = paths.reduce((o, str) => {\n    rx.lastIndex = 0\n    const first = rx.exec(str)\n    const next = rx.exec(str)\n\n    // ns is the top-level path segment, brackets + quoting removed.\n    let ns = first[1] !== undefined\n      ? first[1].replace(/^(?:\"|'|`)(.*)(?:\"|'|`)$/, '$1')\n      : first[0]\n\n    if (ns === '*') {\n      ns = wildcardFirstSym\n    }\n\n    // top level key:\n    if (next === null) {\n      o[ns] = null\n      return o\n    }\n\n    // path with at least two segments:\n    // if ns is already redacted at the top level, ignore lower level redactions\n    if (o[ns] === null) {\n      return o\n    }\n\n    const { index } = next\n    const nextPath = `${str.substr(index, str.length - 1)}`\n\n    o[ns] = o[ns] || []\n\n    // shape is a mix of paths beginning with literal values and wildcard\n    // paths [ \"a.b.c\", \"*.b.z\" ] should reduce to a shape of\n    // { \"a\": [ \"b.c\", \"b.z\" ], *: [ \"b.z\" ] }\n    // note: \"b.z\" is in both \"a\" and * arrays because \"a\" matches the wildcard.\n    // (* entry has wildcardFirstSym as key)\n    if (ns !== wildcardFirstSym && o[ns].length === 0) {\n      // first time ns's get all '*' redactions so far\n      o[ns].push(...(o[wildcardFirstSym] || []))\n    }\n\n    if (ns === wildcardFirstSym) {\n      // new * path gets added to all previously registered literal ns's.\n      Object.keys(o).forEach(function (k) {\n        if (o[k]) {\n          o[k].push(nextPath)\n        }\n      })\n    }\n\n    o[ns].push(nextPath)\n    return o\n  }, {})\n\n  // the redactor assigned to the format symbol key\n  // provides top level redaction for instances where\n  // an object is interpolated into the msg string\n  const result = {\n    [redactFmtSym]: slowRedact({ paths, censor, serialize, strict, remove })\n  }\n\n  const topCensor = (...args) => {\n    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)\n  }\n\n  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {\n    // top level key:\n    if (shape[k] === null) {\n      o[k] = (value) => topCensor(value, [k])\n    } else {\n      const wrappedCensor = typeof censor === 'function'\n        ? (value, path) => {\n            return censor(value, [k, ...path])\n          }\n        : censor\n      o[k] = slowRedact({\n        paths: shape[k],\n        censor: wrappedCensor,\n        serialize,\n        strict,\n        remove\n      })\n    }\n    return o\n  }, result)\n}\n\nfunction handle (opts) {\n  if (Array.isArray(opts)) {\n    opts = { paths: opts, censor: CENSOR }\n    return opts\n  }\n  let { paths, censor = CENSOR, remove } = opts\n  if (Array.isArray(paths) === false) { throw Error('pino – redact must contain an array of strings') }\n  if (remove === true) censor = undefined\n\n  return { paths, censor, remove }\n}\n\nmodule.exports = redaction\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3hDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQywyREFBVzs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx3QkFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRO0FBQ3BCLHdCQUF3QixrQ0FBa0M7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxJQUFJOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUEwQztBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLHdDQUF3QztBQUN4Qzs7QUFFQSxXQUFXO0FBQ1g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3JlZGFjdGlvbi5qcz9iNTc1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzbG93UmVkYWN0ID0gcmVxdWlyZSgnc2xvdy1yZWRhY3QnKVxuY29uc3QgeyByZWRhY3RGbXRTeW0sIHdpbGRjYXJkRmlyc3RTeW0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5cbi8vIEN1c3RvbSByeCByZWdleCBlcXVpdmFsZW50IHRvIGZhc3QtcmVkYWN0J3MgcnhcbmNvbnN0IHJ4ID0gL1teLltcXF1dK3xcXFsoW15bXFxdXSo/KVxcXS9nXG5cbmNvbnN0IENFTlNPUiA9ICdbUmVkYWN0ZWRdJ1xuY29uc3Qgc3RyaWN0ID0gZmFsc2UgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBjb25maWd1cmFibGU/XG5cbmZ1bmN0aW9uIHJlZGFjdGlvbiAob3B0cywgc2VyaWFsaXplKSB7XG4gIGNvbnN0IHsgcGF0aHMsIGNlbnNvciwgcmVtb3ZlIH0gPSBoYW5kbGUob3B0cylcblxuICBjb25zdCBzaGFwZSA9IHBhdGhzLnJlZHVjZSgobywgc3RyKSA9PiB7XG4gICAgcngubGFzdEluZGV4ID0gMFxuICAgIGNvbnN0IGZpcnN0ID0gcnguZXhlYyhzdHIpXG4gICAgY29uc3QgbmV4dCA9IHJ4LmV4ZWMoc3RyKVxuXG4gICAgLy8gbnMgaXMgdGhlIHRvcC1sZXZlbCBwYXRoIHNlZ21lbnQsIGJyYWNrZXRzICsgcXVvdGluZyByZW1vdmVkLlxuICAgIGxldCBucyA9IGZpcnN0WzFdICE9PSB1bmRlZmluZWRcbiAgICAgID8gZmlyc3RbMV0ucmVwbGFjZSgvXig/OlwifCd8YCkoLiopKD86XCJ8J3xgKSQvLCAnJDEnKVxuICAgICAgOiBmaXJzdFswXVxuXG4gICAgaWYgKG5zID09PSAnKicpIHtcbiAgICAgIG5zID0gd2lsZGNhcmRGaXJzdFN5bVxuICAgIH1cblxuICAgIC8vIHRvcCBsZXZlbCBrZXk6XG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIG9bbnNdID0gbnVsbFxuICAgICAgcmV0dXJuIG9cbiAgICB9XG5cbiAgICAvLyBwYXRoIHdpdGggYXQgbGVhc3QgdHdvIHNlZ21lbnRzOlxuICAgIC8vIGlmIG5zIGlzIGFscmVhZHkgcmVkYWN0ZWQgYXQgdGhlIHRvcCBsZXZlbCwgaWdub3JlIGxvd2VyIGxldmVsIHJlZGFjdGlvbnNcbiAgICBpZiAob1tuc10gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBvXG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmRleCB9ID0gbmV4dFxuICAgIGNvbnN0IG5leHRQYXRoID0gYCR7c3RyLnN1YnN0cihpbmRleCwgc3RyLmxlbmd0aCAtIDEpfWBcblxuICAgIG9bbnNdID0gb1tuc10gfHwgW11cblxuICAgIC8vIHNoYXBlIGlzIGEgbWl4IG9mIHBhdGhzIGJlZ2lubmluZyB3aXRoIGxpdGVyYWwgdmFsdWVzIGFuZCB3aWxkY2FyZFxuICAgIC8vIHBhdGhzIFsgXCJhLmIuY1wiLCBcIiouYi56XCIgXSBzaG91bGQgcmVkdWNlIHRvIGEgc2hhcGUgb2ZcbiAgICAvLyB7IFwiYVwiOiBbIFwiYi5jXCIsIFwiYi56XCIgXSwgKjogWyBcImIuelwiIF0gfVxuICAgIC8vIG5vdGU6IFwiYi56XCIgaXMgaW4gYm90aCBcImFcIiBhbmQgKiBhcnJheXMgYmVjYXVzZSBcImFcIiBtYXRjaGVzIHRoZSB3aWxkY2FyZC5cbiAgICAvLyAoKiBlbnRyeSBoYXMgd2lsZGNhcmRGaXJzdFN5bSBhcyBrZXkpXG4gICAgaWYgKG5zICE9PSB3aWxkY2FyZEZpcnN0U3ltICYmIG9bbnNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZmlyc3QgdGltZSBucydzIGdldCBhbGwgJyonIHJlZGFjdGlvbnMgc28gZmFyXG4gICAgICBvW25zXS5wdXNoKC4uLihvW3dpbGRjYXJkRmlyc3RTeW1dIHx8IFtdKSlcbiAgICB9XG5cbiAgICBpZiAobnMgPT09IHdpbGRjYXJkRmlyc3RTeW0pIHtcbiAgICAgIC8vIG5ldyAqIHBhdGggZ2V0cyBhZGRlZCB0byBhbGwgcHJldmlvdXNseSByZWdpc3RlcmVkIGxpdGVyYWwgbnMncy5cbiAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKG9ba10pIHtcbiAgICAgICAgICBvW2tdLnB1c2gobmV4dFBhdGgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgb1tuc10ucHVzaChuZXh0UGF0aClcbiAgICByZXR1cm4gb1xuICB9LCB7fSlcblxuICAvLyB0aGUgcmVkYWN0b3IgYXNzaWduZWQgdG8gdGhlIGZvcm1hdCBzeW1ib2wga2V5XG4gIC8vIHByb3ZpZGVzIHRvcCBsZXZlbCByZWRhY3Rpb24gZm9yIGluc3RhbmNlcyB3aGVyZVxuICAvLyBhbiBvYmplY3QgaXMgaW50ZXJwb2xhdGVkIGludG8gdGhlIG1zZyBzdHJpbmdcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIFtyZWRhY3RGbXRTeW1dOiBzbG93UmVkYWN0KHsgcGF0aHMsIGNlbnNvciwgc2VyaWFsaXplLCBzdHJpY3QsIHJlbW92ZSB9KVxuICB9XG5cbiAgY29uc3QgdG9wQ2Vuc29yID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlcmlhbGl6ZShjZW5zb3IoLi4uYXJncykpIDogc2VyaWFsaXplKGNlbnNvcilcbiAgfVxuXG4gIHJldHVybiBbLi4uT2JqZWN0LmtleXMoc2hhcGUpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNoYXBlKV0ucmVkdWNlKChvLCBrKSA9PiB7XG4gICAgLy8gdG9wIGxldmVsIGtleTpcbiAgICBpZiAoc2hhcGVba10gPT09IG51bGwpIHtcbiAgICAgIG9ba10gPSAodmFsdWUpID0+IHRvcENlbnNvcih2YWx1ZSwgW2tdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cmFwcGVkQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/ICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNlbnNvcih2YWx1ZSwgW2ssIC4uLnBhdGhdKVxuICAgICAgICAgIH1cbiAgICAgICAgOiBjZW5zb3JcbiAgICAgIG9ba10gPSBzbG93UmVkYWN0KHtcbiAgICAgICAgcGF0aHM6IHNoYXBlW2tdLFxuICAgICAgICBjZW5zb3I6IHdyYXBwZWRDZW5zb3IsXG4gICAgICAgIHNlcmlhbGl6ZSxcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICByZW1vdmVcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBvXG4gIH0sIHJlc3VsdClcbn1cblxuZnVuY3Rpb24gaGFuZGxlIChvcHRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgb3B0cyA9IHsgcGF0aHM6IG9wdHMsIGNlbnNvcjogQ0VOU09SIH1cbiAgICByZXR1cm4gb3B0c1xuICB9XG4gIGxldCB7IHBhdGhzLCBjZW5zb3IgPSBDRU5TT1IsIHJlbW92ZSB9ID0gb3B0c1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRocykgPT09IGZhbHNlKSB7IHRocm93IEVycm9yKCdwaW5vIOKAkyByZWRhY3QgbXVzdCBjb250YWluIGFuIGFycmF5IG9mIHN0cmluZ3MnKSB9XG4gIGlmIChyZW1vdmUgPT09IHRydWUpIGNlbnNvciA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB7IHBhdGhzLCBjZW5zb3IsIHJlbW92ZSB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVkYWN0aW9uXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/redaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/symbols.js":
/*!******************************************!*\
  !*** ./node_modules/pino/lib/symbols.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst setLevelSym = Symbol('pino.setLevel')\nconst getLevelSym = Symbol('pino.getLevel')\nconst levelValSym = Symbol('pino.levelVal')\nconst levelCompSym = Symbol('pino.levelComp')\nconst useLevelLabelsSym = Symbol('pino.useLevelLabels')\nconst useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels')\nconst mixinSym = Symbol('pino.mixin')\n\nconst lsCacheSym = Symbol('pino.lsCache')\nconst chindingsSym = Symbol('pino.chindings')\n\nconst asJsonSym = Symbol('pino.asJson')\nconst writeSym = Symbol('pino.write')\nconst redactFmtSym = Symbol('pino.redactFmt')\n\nconst timeSym = Symbol('pino.time')\nconst timeSliceIndexSym = Symbol('pino.timeSliceIndex')\nconst streamSym = Symbol('pino.stream')\nconst stringifySym = Symbol('pino.stringify')\nconst stringifySafeSym = Symbol('pino.stringifySafe')\nconst stringifiersSym = Symbol('pino.stringifiers')\nconst endSym = Symbol('pino.end')\nconst formatOptsSym = Symbol('pino.formatOpts')\nconst messageKeySym = Symbol('pino.messageKey')\nconst errorKeySym = Symbol('pino.errorKey')\nconst nestedKeySym = Symbol('pino.nestedKey')\nconst nestedKeyStrSym = Symbol('pino.nestedKeyStr')\nconst mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy')\nconst msgPrefixSym = Symbol('pino.msgPrefix')\n\nconst wildcardFirstSym = Symbol('pino.wildcardFirst')\n\n// public symbols, no need to use the same pino\n// version for these\nconst serializersSym = Symbol.for('pino.serializers')\nconst formattersSym = Symbol.for('pino.formatters')\nconst hooksSym = Symbol.for('pino.hooks')\nconst needsMetadataGsym = Symbol.for('pino.metadata')\n\nmodule.exports = {\n  setLevelSym,\n  getLevelSym,\n  levelValSym,\n  levelCompSym,\n  useLevelLabelsSym,\n  mixinSym,\n  lsCacheSym,\n  chindingsSym,\n  asJsonSym,\n  writeSym,\n  serializersSym,\n  redactFmtSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifySafeSym,\n  stringifiersSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeySym,\n  wildcardFirstSym,\n  needsMetadataGsym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym,\n  nestedKeyStrSym,\n  mixinMergeStrategySym,\n  msgPrefixSym\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3N5bWJvbHMuanM/NzFiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc2V0TGV2ZWxTeW0gPSBTeW1ib2woJ3Bpbm8uc2V0TGV2ZWwnKVxuY29uc3QgZ2V0TGV2ZWxTeW0gPSBTeW1ib2woJ3Bpbm8uZ2V0TGV2ZWwnKVxuY29uc3QgbGV2ZWxWYWxTeW0gPSBTeW1ib2woJ3Bpbm8ubGV2ZWxWYWwnKVxuY29uc3QgbGV2ZWxDb21wU3ltID0gU3ltYm9sKCdwaW5vLmxldmVsQ29tcCcpXG5jb25zdCB1c2VMZXZlbExhYmVsc1N5bSA9IFN5bWJvbCgncGluby51c2VMZXZlbExhYmVscycpXG5jb25zdCB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltID0gU3ltYm9sKCdwaW5vLnVzZU9ubHlDdXN0b21MZXZlbHMnKVxuY29uc3QgbWl4aW5TeW0gPSBTeW1ib2woJ3Bpbm8ubWl4aW4nKVxuXG5jb25zdCBsc0NhY2hlU3ltID0gU3ltYm9sKCdwaW5vLmxzQ2FjaGUnKVxuY29uc3QgY2hpbmRpbmdzU3ltID0gU3ltYm9sKCdwaW5vLmNoaW5kaW5ncycpXG5cbmNvbnN0IGFzSnNvblN5bSA9IFN5bWJvbCgncGluby5hc0pzb24nKVxuY29uc3Qgd3JpdGVTeW0gPSBTeW1ib2woJ3Bpbm8ud3JpdGUnKVxuY29uc3QgcmVkYWN0Rm10U3ltID0gU3ltYm9sKCdwaW5vLnJlZGFjdEZtdCcpXG5cbmNvbnN0IHRpbWVTeW0gPSBTeW1ib2woJ3Bpbm8udGltZScpXG5jb25zdCB0aW1lU2xpY2VJbmRleFN5bSA9IFN5bWJvbCgncGluby50aW1lU2xpY2VJbmRleCcpXG5jb25zdCBzdHJlYW1TeW0gPSBTeW1ib2woJ3Bpbm8uc3RyZWFtJylcbmNvbnN0IHN0cmluZ2lmeVN5bSA9IFN5bWJvbCgncGluby5zdHJpbmdpZnknKVxuY29uc3Qgc3RyaW5naWZ5U2FmZVN5bSA9IFN5bWJvbCgncGluby5zdHJpbmdpZnlTYWZlJylcbmNvbnN0IHN0cmluZ2lmaWVyc1N5bSA9IFN5bWJvbCgncGluby5zdHJpbmdpZmllcnMnKVxuY29uc3QgZW5kU3ltID0gU3ltYm9sKCdwaW5vLmVuZCcpXG5jb25zdCBmb3JtYXRPcHRzU3ltID0gU3ltYm9sKCdwaW5vLmZvcm1hdE9wdHMnKVxuY29uc3QgbWVzc2FnZUtleVN5bSA9IFN5bWJvbCgncGluby5tZXNzYWdlS2V5JylcbmNvbnN0IGVycm9yS2V5U3ltID0gU3ltYm9sKCdwaW5vLmVycm9yS2V5JylcbmNvbnN0IG5lc3RlZEtleVN5bSA9IFN5bWJvbCgncGluby5uZXN0ZWRLZXknKVxuY29uc3QgbmVzdGVkS2V5U3RyU3ltID0gU3ltYm9sKCdwaW5vLm5lc3RlZEtleVN0cicpXG5jb25zdCBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0gPSBTeW1ib2woJ3Bpbm8ubWl4aW5NZXJnZVN0cmF0ZWd5JylcbmNvbnN0IG1zZ1ByZWZpeFN5bSA9IFN5bWJvbCgncGluby5tc2dQcmVmaXgnKVxuXG5jb25zdCB3aWxkY2FyZEZpcnN0U3ltID0gU3ltYm9sKCdwaW5vLndpbGRjYXJkRmlyc3QnKVxuXG4vLyBwdWJsaWMgc3ltYm9scywgbm8gbmVlZCB0byB1c2UgdGhlIHNhbWUgcGlub1xuLy8gdmVyc2lvbiBmb3IgdGhlc2VcbmNvbnN0IHNlcmlhbGl6ZXJzU3ltID0gU3ltYm9sLmZvcigncGluby5zZXJpYWxpemVycycpXG5jb25zdCBmb3JtYXR0ZXJzU3ltID0gU3ltYm9sLmZvcigncGluby5mb3JtYXR0ZXJzJylcbmNvbnN0IGhvb2tzU3ltID0gU3ltYm9sLmZvcigncGluby5ob29rcycpXG5jb25zdCBuZWVkc01ldGFkYXRhR3N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8ubWV0YWRhdGEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0TGV2ZWxTeW0sXG4gIGdldExldmVsU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgbGV2ZWxDb21wU3ltLFxuICB1c2VMZXZlbExhYmVsc1N5bSxcbiAgbWl4aW5TeW0sXG4gIGxzQ2FjaGVTeW0sXG4gIGNoaW5kaW5nc1N5bSxcbiAgYXNKc29uU3ltLFxuICB3cml0ZVN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIHJlZGFjdEZtdFN5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIGVuZFN5bSxcbiAgZm9ybWF0T3B0c1N5bSxcbiAgbWVzc2FnZUtleVN5bSxcbiAgZXJyb3JLZXlTeW0sXG4gIG5lc3RlZEtleVN5bSxcbiAgd2lsZGNhcmRGaXJzdFN5bSxcbiAgbmVlZHNNZXRhZGF0YUdzeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGhvb2tzU3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgbXNnUHJlZml4U3ltXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/time.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/time.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst nullTime = () => ''\n\nconst epochTime = () => `,\"time\":${Date.now()}`\n\nconst unixTime = () => `,\"time\":${Math.round(Date.now() / 1000.0)}`\n\nconst isoTime = () => `,\"time\":\"${new Date(Date.now()).toISOString()}\"` // using Date.now() for testability\n\nconst NS_PER_MS = 1_000_000n\nconst NS_PER_SEC = 1_000_000_000n\n\nconst startWallTimeNs = BigInt(Date.now()) * NS_PER_MS\nconst startHrTime = process.hrtime.bigint()\n\nconst isoTimeNano = () => {\n  const elapsedNs = process.hrtime.bigint() - startHrTime\n  const currentTimeNs = startWallTimeNs + elapsedNs\n\n  const secondsSinceEpoch = currentTimeNs / NS_PER_SEC\n  const nanosWithinSecond = currentTimeNs % NS_PER_SEC\n\n  const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1_000_000n)\n  const date = new Date(msSinceEpoch)\n\n  const year = date.getUTCFullYear()\n  const month = (date.getUTCMonth() + 1).toString().padStart(2, '0')\n  const day = date.getUTCDate().toString().padStart(2, '0')\n  const hours = date.getUTCHours().toString().padStart(2, '0')\n  const minutes = date.getUTCMinutes().toString().padStart(2, '0')\n  const seconds = date.getUTCSeconds().toString().padStart(2, '0')\n\n  return `,\"time\":\"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond\n    .toString()\n    .padStart(9, '0')}Z\"`\n}\n\nmodule.exports = { nullTime, epochTime, unixTime, isoTime, isoTimeNano }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxtQ0FBbUMsV0FBVzs7QUFFOUMsa0NBQWtDLGdDQUFnQzs7QUFFbEUsa0NBQWtDLG1DQUFtQzs7QUFFckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUksR0FBRyxNQUFNLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRztBQUM1RTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3RpbWUuanM/NGIwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbnVsbFRpbWUgPSAoKSA9PiAnJ1xuXG5jb25zdCBlcG9jaFRpbWUgPSAoKSA9PiBgLFwidGltZVwiOiR7RGF0ZS5ub3coKX1gXG5cbmNvbnN0IHVuaXhUaW1lID0gKCkgPT4gYCxcInRpbWVcIjoke01hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDAuMCl9YFxuXG5jb25zdCBpc29UaW1lID0gKCkgPT4gYCxcInRpbWVcIjpcIiR7bmV3IERhdGUoRGF0ZS5ub3coKSkudG9JU09TdHJpbmcoKX1cImAgLy8gdXNpbmcgRGF0ZS5ub3coKSBmb3IgdGVzdGFiaWxpdHlcblxuY29uc3QgTlNfUEVSX01TID0gMV8wMDBfMDAwblxuY29uc3QgTlNfUEVSX1NFQyA9IDFfMDAwXzAwMF8wMDBuXG5cbmNvbnN0IHN0YXJ0V2FsbFRpbWVOcyA9IEJpZ0ludChEYXRlLm5vdygpKSAqIE5TX1BFUl9NU1xuY29uc3Qgc3RhcnRIclRpbWUgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKVxuXG5jb25zdCBpc29UaW1lTmFubyA9ICgpID0+IHtcbiAgY29uc3QgZWxhcHNlZE5zID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCkgLSBzdGFydEhyVGltZVxuICBjb25zdCBjdXJyZW50VGltZU5zID0gc3RhcnRXYWxsVGltZU5zICsgZWxhcHNlZE5zXG5cbiAgY29uc3Qgc2Vjb25kc1NpbmNlRXBvY2ggPSBjdXJyZW50VGltZU5zIC8gTlNfUEVSX1NFQ1xuICBjb25zdCBuYW5vc1dpdGhpblNlY29uZCA9IGN1cnJlbnRUaW1lTnMgJSBOU19QRVJfU0VDXG5cbiAgY29uc3QgbXNTaW5jZUVwb2NoID0gTnVtYmVyKHNlY29uZHNTaW5jZUVwb2NoICogMTAwMG4gKyBuYW5vc1dpdGhpblNlY29uZCAvIDFfMDAwXzAwMG4pXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShtc1NpbmNlRXBvY2gpXG5cbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKVxuICBjb25zdCBtb250aCA9IChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgZGF5ID0gZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcblxuICByZXR1cm4gYCxcInRpbWVcIjpcIiR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cnN9OiR7bWludXRlc306JHtzZWNvbmRzfS4ke25hbm9zV2l0aGluU2Vjb25kXG4gICAgLnRvU3RyaW5nKClcbiAgICAucGFkU3RhcnQoOSwgJzAnKX1aXCJgXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBudWxsVGltZSwgZXBvY2hUaW1lLCB1bml4VGltZSwgaXNvVGltZSwgaXNvVGltZU5hbm8gfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/tools.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/tools.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst diagChan = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\")\nconst format = __webpack_require__(/*! quick-format-unescaped */ \"(ssr)/./node_modules/quick-format-unescaped/index.js\")\nconst { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ \"(ssr)/./node_modules/pino-std-serializers/index.js\")\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"(ssr)/./node_modules/sonic-boom/index.js\")\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(ssr)/./node_modules/on-exit-leak-free/index.js\")\nconst {\n  lsCacheSym,\n  chindingsSym,\n  writeSym,\n  serializersSym,\n  formatOptsSym,\n  endSym,\n  stringifiersSym,\n  stringifySym,\n  stringifySafeSym,\n  wildcardFirstSym,\n  nestedKeySym,\n  formattersSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeyStrSym,\n  msgPrefixSym\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { isMainThread } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\nconst transport = __webpack_require__(/*! ./transport */ \"(ssr)/./node_modules/pino/lib/transport.js\")\n\nconst asJsonChan = diagChan.tracingChannel('pino_asJson')\n\nfunction noop () {\n}\n\nfunction genLog (level, hook) {\n  if (!hook) return LOG\n\n  return function hookWrappedLog (...args) {\n    hook.call(this, args, LOG, level)\n  }\n\n  function LOG (o, ...n) {\n    if (typeof o === 'object') {\n      let msg = o\n      if (o !== null) {\n        if (o.method && o.headers && o.socket) {\n          o = mapHttpRequest(o)\n        } else if (typeof o.setHeader === 'function') {\n          o = mapHttpResponse(o)\n        }\n      }\n      let formatParams\n      if (msg === null && n.length === 0) {\n        formatParams = [null]\n      } else {\n        msg = n.shift()\n        formatParams = n\n      }\n      // We do not use a coercive check for `msg` as it is\n      // measurably slower than the explicit checks.\n      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {\n        msg = this[msgPrefixSym] + msg\n      }\n      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level)\n    } else {\n      let msg = o === undefined ? n.shift() : o\n\n      // We do not use a coercive check for `msg` as it is\n      // measurably slower than the explicit checks.\n      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {\n        msg = this[msgPrefixSym] + msg\n      }\n      this[writeSym](null, format(msg, n, this[formatOptsSym]), level)\n    }\n  }\n}\n\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction asString (str) {\n  let result = ''\n  let last = 0\n  let found = false\n  let point = 255\n  const l = str.length\n  if (l > 100) {\n    return JSON.stringify(str)\n  }\n  for (var i = 0; i < l && point >= 32; i++) {\n    point = str.charCodeAt(i)\n    if (point === 34 || point === 92) {\n      result += str.slice(last, i) + '\\\\'\n      last = i\n      found = true\n    }\n  }\n  if (!found) {\n    result = str\n  } else {\n    result += str.slice(last)\n  }\n  return point < 32 ? JSON.stringify(str) : '\"' + result + '\"'\n}\n\n/**\n * `asJson` wraps `_asJson` in order to facilitate generating diagnostics.\n *\n * @param {object} obj The merging object passed to the log method.\n * @param {string} msg The log message passed to the log method.\n * @param {number} num The log level number.\n * @param {number} time The log time in milliseconds.\n *\n * @returns {string}\n */\nfunction asJson (obj, msg, num, time) {\n  if (asJsonChan.hasSubscribers === false) {\n    return _asJson.call(this, obj, msg, num, time)\n  }\n\n  const store = { instance: this, arguments }\n  return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time)\n}\n\n/**\n * `_asJson` parses all collected data and generates the finalized newline\n * delimited JSON string.\n *\n * @param {object} obj The merging object passed to the log method.\n * @param {string} msg The log message passed to the log method.\n * @param {number} num The log level number.\n * @param {number} time The log time in milliseconds.\n *\n * @returns {string} The finalized log string terminated with a newline.\n * @private\n */\nfunction _asJson (obj, msg, num, time) {\n  const stringify = this[stringifySym]\n  const stringifySafe = this[stringifySafeSym]\n  const stringifiers = this[stringifiersSym]\n  const end = this[endSym]\n  const chindings = this[chindingsSym]\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const messageKey = this[messageKeySym]\n  const errorKey = this[errorKeySym]\n  let data = this[lsCacheSym][num] + time\n\n  // we need the child bindings added to the output first so instance logged\n  // objects can take precedence when JSON.parse-ing the resulting log line\n  data = data + chindings\n\n  let value\n  if (formatters.log) {\n    obj = formatters.log(obj)\n  }\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  let propStr = ''\n  for (const key in obj) {\n    value = obj[key]\n    if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n      if (serializers[key]) {\n        value = serializers[key](value)\n      } else if (key === errorKey && serializers.err) {\n        value = serializers.err(value)\n      }\n\n      const stringifier = stringifiers[key] || wildcardStringifier\n\n      switch (typeof value) {\n        case 'undefined':\n        case 'function':\n          continue\n        case 'number':\n          /* eslint no-fallthrough: \"off\" */\n          if (Number.isFinite(value) === false) {\n            value = null\n          }\n        // this case explicitly falls through to the next one\n        case 'boolean':\n          if (stringifier) value = stringifier(value)\n          break\n        case 'string':\n          value = (stringifier || asString)(value)\n          break\n        default:\n          value = (stringifier || stringify)(value, stringifySafe)\n      }\n      if (value === undefined) continue\n      const strKey = asString(key)\n      propStr += ',' + strKey + ':' + value\n    }\n  }\n\n  let msgStr = ''\n  if (msg !== undefined) {\n    value = serializers[messageKey] ? serializers[messageKey](msg) : msg\n    const stringifier = stringifiers[messageKey] || wildcardStringifier\n\n    switch (typeof value) {\n      case 'function':\n        break\n      case 'number':\n        /* eslint no-fallthrough: \"off\" */\n        if (Number.isFinite(value) === false) {\n          value = null\n        }\n      // this case explicitly falls through to the next one\n      case 'boolean':\n        if (stringifier) value = stringifier(value)\n        msgStr = ',\"' + messageKey + '\":' + value\n        break\n      case 'string':\n        value = (stringifier || asString)(value)\n        msgStr = ',\"' + messageKey + '\":' + value\n        break\n      default:\n        value = (stringifier || stringify)(value, stringifySafe)\n        msgStr = ',\"' + messageKey + '\":' + value\n    }\n  }\n\n  if (this[nestedKeySym] && propStr) {\n    // place all the obj properties under the specified key\n    // the nested key is already formatted from the constructor\n    return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end\n  } else {\n    return data + propStr + msgStr + end\n  }\n}\n\nfunction asChindings (instance, bindings) {\n  let value\n  let data = instance[chindingsSym]\n  const stringify = instance[stringifySym]\n  const stringifySafe = instance[stringifySafeSym]\n  const stringifiers = instance[stringifiersSym]\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  const serializers = instance[serializersSym]\n  const formatter = instance[formattersSym].bindings\n  bindings = formatter(bindings)\n\n  for (const key in bindings) {\n    value = bindings[key]\n    const valid = (key.length < 5 || (key !== 'level' &&\n      key !== 'serializers' &&\n      key !== 'formatters' &&\n      key !== 'customLevels')) &&\n      bindings.hasOwnProperty(key) &&\n      value !== undefined\n    if (valid === true) {\n      value = serializers[key] ? serializers[key](value) : value\n      value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe)\n      if (value === undefined) continue\n      data += ',\"' + key + '\":' + value\n    }\n  }\n  return data\n}\n\nfunction hasBeenTampered (stream) {\n  return stream.write !== stream.constructor.prototype.write\n}\n\nfunction buildSafeSonicBoom (opts) {\n  const stream = new SonicBoom(opts)\n  stream.on('error', filterBrokenPipe)\n  // If we are sync: false, we must flush on exit\n  if (!opts.sync && isMainThread) {\n    onExit.register(stream, autoEnd)\n\n    stream.on('close', function () {\n      onExit.unregister(stream)\n    })\n  }\n  return stream\n\n  function filterBrokenPipe (err) {\n    // Impossible to replicate across all operating systems\n    /* istanbul ignore next */\n    if (err.code === 'EPIPE') {\n      // If we get EPIPE, we should stop logging here\n      // however we have no control to the consumer of\n      // SonicBoom, so we just overwrite the write method\n      stream.write = noop\n      stream.end = noop\n      stream.flushSync = noop\n      stream.destroy = noop\n      return\n    }\n    stream.removeListener('error', filterBrokenPipe)\n    stream.emit('error', err)\n  }\n}\n\nfunction autoEnd (stream, eventName) {\n  // This check is needed only on some platforms\n  /* istanbul ignore next */\n  if (stream.destroyed) {\n    return\n  }\n\n  if (eventName === 'beforeExit') {\n    // We still have an event loop, let's use it\n    stream.flush()\n    stream.on('drain', function () {\n      stream.end()\n    })\n  } else {\n    // For some reason istanbul is not detecting this, but it's there\n    /* istanbul ignore next */\n    // We do not have an event loop, so flush synchronously\n    stream.flushSync()\n  }\n}\n\nfunction createArgsNormalizer (defaultOptions) {\n  return function normalizeArgs (instance, caller, opts = {}, stream) {\n    // support stream as a string\n    if (typeof opts === 'string') {\n      stream = buildSafeSonicBoom({ dest: opts })\n      opts = {}\n    } else if (typeof stream === 'string') {\n      if (opts && opts.transport) {\n        throw Error('only one of option.transport or stream can be specified')\n      }\n      stream = buildSafeSonicBoom({ dest: stream })\n    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {\n      stream = opts\n      opts = {}\n    } else if (opts.transport) {\n      if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {\n        throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)')\n      }\n      if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {\n        throw Error('option.transport.targets do not allow custom level formatters')\n      }\n\n      let customLevels\n      if (opts.customLevels) {\n        customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels)\n      }\n      stream = transport({ caller, ...opts.transport, levels: customLevels })\n    }\n    opts = Object.assign({}, defaultOptions, opts)\n    opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers)\n    opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters)\n\n    if (opts.prettyPrint) {\n      throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)')\n    }\n\n    const { enabled, onChild } = opts\n    if (enabled === false) opts.level = 'silent'\n    if (!onChild) opts.onChild = noop\n    if (!stream) {\n      if (!hasBeenTampered(process.stdout)) {\n        // If process.stdout.fd is undefined, it means that we are running\n        // in a worker thread. Let's assume we are logging to file descriptor 1.\n        stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 })\n      } else {\n        stream = process.stdout\n      }\n    }\n    return { opts, stream }\n  }\n}\n\nfunction stringify (obj, stringifySafeFn) {\n  try {\n    return JSON.stringify(obj)\n  } catch (_) {\n    try {\n      const stringify = stringifySafeFn || this[stringifySafeSym]\n      return stringify(obj)\n    } catch (_) {\n      return '\"[unable to serialize, circular reference is too complex to analyze]\"'\n    }\n  }\n}\n\nfunction buildFormatters (level, bindings, log) {\n  return {\n    level,\n    bindings,\n    log\n  }\n}\n\n/**\n * Convert a string integer file descriptor to a proper native integer\n * file descriptor.\n *\n * @param {string} destination The file descriptor string to attempt to convert.\n *\n * @returns {Number}\n */\nfunction normalizeDestFileDescriptor (destination) {\n  const fd = Number(destination)\n  if (typeof destination === 'string' && Number.isFinite(fd)) {\n    return fd\n  }\n  // destination could be undefined if we are in a worker\n  if (destination === undefined) {\n    // This is stdout in UNIX systems\n    return 1\n  }\n  return destination\n}\n\nmodule.exports = {\n  noop,\n  buildSafeSonicBoom,\n  asChindings,\n  asJson,\n  genLog,\n  createArgsNormalizer,\n  stringify,\n  buildFormatters,\n  normalizeDestFileDescriptor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdG9vbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsMERBQTBCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxvRkFBd0I7QUFDL0MsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLGdGQUFzQjtBQUMxRSxrQkFBa0IsbUJBQU8sQ0FBQyw0REFBWTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsMEVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBVztBQUN2QixRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHNDQUFnQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywrREFBYTs7QUFFdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRCxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBLDJCQUEyQixpREFBaUQ7QUFDNUU7QUFDQSwyQkFBMkI7QUFDM0IsdUNBQXVDO0FBQ3ZDLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdG9vbHMuanM/MmEzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuXG5jb25zdCBkaWFnQ2hhbiA9IHJlcXVpcmUoJ25vZGU6ZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCdxdWljay1mb3JtYXQtdW5lc2NhcGVkJylcbmNvbnN0IHsgbWFwSHR0cFJlcXVlc3QsIG1hcEh0dHBSZXNwb25zZSB9ID0gcmVxdWlyZSgncGluby1zdGQtc2VyaWFsaXplcnMnKVxuY29uc3QgU29uaWNCb29tID0gcmVxdWlyZSgnc29uaWMtYm9vbScpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCB7XG4gIGxzQ2FjaGVTeW0sXG4gIGNoaW5kaW5nc1N5bSxcbiAgd3JpdGVTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBlbmRTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICB3aWxkY2FyZEZpcnN0U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzTWFpblRocmVhZCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuY29uc3QgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKVxuXG5jb25zdCBhc0pzb25DaGFuID0gZGlhZ0NoYW4udHJhY2luZ0NoYW5uZWwoJ3Bpbm9fYXNKc29uJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7XG59XG5cbmZ1bmN0aW9uIGdlbkxvZyAobGV2ZWwsIGhvb2spIHtcbiAgaWYgKCFob29rKSByZXR1cm4gTE9HXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGhvb2tXcmFwcGVkTG9nICguLi5hcmdzKSB7XG4gICAgaG9vay5jYWxsKHRoaXMsIGFyZ3MsIExPRywgbGV2ZWwpXG4gIH1cblxuICBmdW5jdGlvbiBMT0cgKG8sIC4uLm4pIHtcbiAgICBpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgbXNnID0gb1xuICAgICAgaWYgKG8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG8ubWV0aG9kICYmIG8uaGVhZGVycyAmJiBvLnNvY2tldCkge1xuICAgICAgICAgIG8gPSBtYXBIdHRwUmVxdWVzdChvKVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvLnNldEhlYWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG8gPSBtYXBIdHRwUmVzcG9uc2UobylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdFBhcmFtc1xuICAgICAgaWYgKG1zZyA9PT0gbnVsbCAmJiBuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3JtYXRQYXJhbXMgPSBbbnVsbF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9IG4uc2hpZnQoKVxuICAgICAgICBmb3JtYXRQYXJhbXMgPSBuXG4gICAgICB9XG4gICAgICAvLyBXZSBkbyBub3QgdXNlIGEgY29lcmNpdmUgY2hlY2sgZm9yIGBtc2dgIGFzIGl0IGlzXG4gICAgICAvLyBtZWFzdXJhYmx5IHNsb3dlciB0aGFuIHRoZSBleHBsaWNpdCBjaGVja3MuXG4gICAgICBpZiAodHlwZW9mIHRoaXNbbXNnUHJlZml4U3ltXSA9PT0gJ3N0cmluZycgJiYgbXNnICE9PSB1bmRlZmluZWQgJiYgbXNnICE9PSBudWxsKSB7XG4gICAgICAgIG1zZyA9IHRoaXNbbXNnUHJlZml4U3ltXSArIG1zZ1xuICAgICAgfVxuICAgICAgdGhpc1t3cml0ZVN5bV0obywgZm9ybWF0KG1zZywgZm9ybWF0UGFyYW1zLCB0aGlzW2Zvcm1hdE9wdHNTeW1dKSwgbGV2ZWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtc2cgPSBvID09PSB1bmRlZmluZWQgPyBuLnNoaWZ0KCkgOiBvXG5cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSBjb2VyY2l2ZSBjaGVjayBmb3IgYG1zZ2AgYXMgaXQgaXNcbiAgICAgIC8vIG1lYXN1cmFibHkgc2xvd2VyIHRoYW4gdGhlIGV4cGxpY2l0IGNoZWNrcy5cbiAgICAgIGlmICh0eXBlb2YgdGhpc1ttc2dQcmVmaXhTeW1dID09PSAnc3RyaW5nJyAmJiBtc2cgIT09IHVuZGVmaW5lZCAmJiBtc2cgIT09IG51bGwpIHtcbiAgICAgICAgbXNnID0gdGhpc1ttc2dQcmVmaXhTeW1dICsgbXNnXG4gICAgICB9XG4gICAgICB0aGlzW3dyaXRlU3ltXShudWxsLCBmb3JtYXQobXNnLCBuLCB0aGlzW2Zvcm1hdE9wdHNTeW1dKSwgbGV2ZWwpXG4gICAgfVxuICB9XG59XG5cbi8vIG1hZ2ljYWxseSBlc2NhcGUgc3RyaW5ncyBmb3IganNvblxuLy8gcmVseWluZyBvbiB0aGVpciBjaGFyQ29kZUF0XG4vLyBldmVyeXRoaW5nIGJlbG93IDMyIG5lZWRzIEpTT04uc3RyaW5naWZ5KClcbi8vIDM0IGFuZCA5MiBoYXBwZW5zIGFsbCB0aGUgdGltZSwgc28gd2Vcbi8vIGhhdmUgYSBmYXN0IGNhc2UgZm9yIHRoZW1cbmZ1bmN0aW9uIGFzU3RyaW5nIChzdHIpIHtcbiAgbGV0IHJlc3VsdCA9ICcnXG4gIGxldCBsYXN0ID0gMFxuICBsZXQgZm91bmQgPSBmYWxzZVxuICBsZXQgcG9pbnQgPSAyNTVcbiAgY29uc3QgbCA9IHN0ci5sZW5ndGhcbiAgaWYgKGwgPiAxMDApIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbCAmJiBwb2ludCA+PSAzMjsgaSsrKSB7XG4gICAgcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChwb2ludCA9PT0gMzQgfHwgcG9pbnQgPT09IDkyKSB7XG4gICAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3QsIGkpICsgJ1xcXFwnXG4gICAgICBsYXN0ID0gaVxuICAgICAgZm91bmQgPSB0cnVlXG4gICAgfVxuICB9XG4gIGlmICghZm91bmQpIHtcbiAgICByZXN1bHQgPSBzdHJcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3QpXG4gIH1cbiAgcmV0dXJuIHBvaW50IDwgMzIgPyBKU09OLnN0cmluZ2lmeShzdHIpIDogJ1wiJyArIHJlc3VsdCArICdcIidcbn1cblxuLyoqXG4gKiBgYXNKc29uYCB3cmFwcyBgX2FzSnNvbmAgaW4gb3JkZXIgdG8gZmFjaWxpdGF0ZSBnZW5lcmF0aW5nIGRpYWdub3N0aWNzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogVGhlIG1lcmdpbmcgb2JqZWN0IHBhc3NlZCB0byB0aGUgbG9nIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgVGhlIGxvZyBtZXNzYWdlIHBhc3NlZCB0byB0aGUgbG9nIG1ldGhvZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGxvZyBsZXZlbCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgbG9nIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFzSnNvbiAob2JqLCBtc2csIG51bSwgdGltZSkge1xuICBpZiAoYXNKc29uQ2hhbi5oYXNTdWJzY3JpYmVycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gX2FzSnNvbi5jYWxsKHRoaXMsIG9iaiwgbXNnLCBudW0sIHRpbWUpXG4gIH1cblxuICBjb25zdCBzdG9yZSA9IHsgaW5zdGFuY2U6IHRoaXMsIGFyZ3VtZW50cyB9XG4gIHJldHVybiBhc0pzb25DaGFuLnRyYWNlU3luYyhfYXNKc29uLCBzdG9yZSwgdGhpcywgb2JqLCBtc2csIG51bSwgdGltZSlcbn1cblxuLyoqXG4gKiBgX2FzSnNvbmAgcGFyc2VzIGFsbCBjb2xsZWN0ZWQgZGF0YSBhbmQgZ2VuZXJhdGVzIHRoZSBmaW5hbGl6ZWQgbmV3bGluZVxuICogZGVsaW1pdGVkIEpTT04gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogVGhlIG1lcmdpbmcgb2JqZWN0IHBhc3NlZCB0byB0aGUgbG9nIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgVGhlIGxvZyBtZXNzYWdlIHBhc3NlZCB0byB0aGUgbG9nIG1ldGhvZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGxvZyBsZXZlbCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgbG9nIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaW5hbGl6ZWQgbG9nIHN0cmluZyB0ZXJtaW5hdGVkIHdpdGggYSBuZXdsaW5lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2FzSnNvbiAob2JqLCBtc2csIG51bSwgdGltZSkge1xuICBjb25zdCBzdHJpbmdpZnkgPSB0aGlzW3N0cmluZ2lmeVN5bV1cbiAgY29uc3Qgc3RyaW5naWZ5U2FmZSA9IHRoaXNbc3RyaW5naWZ5U2FmZVN5bV1cbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gdGhpc1tzdHJpbmdpZmllcnNTeW1dXG4gIGNvbnN0IGVuZCA9IHRoaXNbZW5kU3ltXVxuICBjb25zdCBjaGluZGluZ3MgPSB0aGlzW2NoaW5kaW5nc1N5bV1cbiAgY29uc3Qgc2VyaWFsaXplcnMgPSB0aGlzW3NlcmlhbGl6ZXJzU3ltXVxuICBjb25zdCBmb3JtYXR0ZXJzID0gdGhpc1tmb3JtYXR0ZXJzU3ltXVxuICBjb25zdCBtZXNzYWdlS2V5ID0gdGhpc1ttZXNzYWdlS2V5U3ltXVxuICBjb25zdCBlcnJvcktleSA9IHRoaXNbZXJyb3JLZXlTeW1dXG4gIGxldCBkYXRhID0gdGhpc1tsc0NhY2hlU3ltXVtudW1dICsgdGltZVxuXG4gIC8vIHdlIG5lZWQgdGhlIGNoaWxkIGJpbmRpbmdzIGFkZGVkIHRvIHRoZSBvdXRwdXQgZmlyc3Qgc28gaW5zdGFuY2UgbG9nZ2VkXG4gIC8vIG9iamVjdHMgY2FuIHRha2UgcHJlY2VkZW5jZSB3aGVuIEpTT04ucGFyc2UtaW5nIHRoZSByZXN1bHRpbmcgbG9nIGxpbmVcbiAgZGF0YSA9IGRhdGEgKyBjaGluZGluZ3NcblxuICBsZXQgdmFsdWVcbiAgaWYgKGZvcm1hdHRlcnMubG9nKSB7XG4gICAgb2JqID0gZm9ybWF0dGVycy5sb2cob2JqKVxuICB9XG4gIGNvbnN0IHdpbGRjYXJkU3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNbd2lsZGNhcmRGaXJzdFN5bV1cbiAgbGV0IHByb3BTdHIgPSAnJ1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICB2YWx1ZSA9IG9ialtrZXldXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHNlcmlhbGl6ZXJzW2tleV0pIHtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVyc1trZXldKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGVycm9yS2V5ICYmIHNlcmlhbGl6ZXJzLmVycikge1xuICAgICAgICB2YWx1ZSA9IHNlcmlhbGl6ZXJzLmVycih2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNba2V5XSB8fCB3aWxkY2FyZFN0cmluZ2lmaWVyXG5cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGNhc2UgZXhwbGljaXRseSBmYWxscyB0aHJvdWdoIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICBpZiAoc3RyaW5naWZpZXIpIHZhbHVlID0gc3RyaW5naWZpZXIodmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBhc1N0cmluZykodmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBzdHJpbmdpZnkpKHZhbHVlLCBzdHJpbmdpZnlTYWZlKVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICBjb25zdCBzdHJLZXkgPSBhc1N0cmluZyhrZXkpXG4gICAgICBwcm9wU3RyICs9ICcsJyArIHN0cktleSArICc6JyArIHZhbHVlXG4gICAgfVxuICB9XG5cbiAgbGV0IG1zZ1N0ciA9ICcnXG4gIGlmIChtc2cgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gc2VyaWFsaXplcnNbbWVzc2FnZUtleV0gPyBzZXJpYWxpemVyc1ttZXNzYWdlS2V5XShtc2cpIDogbXNnXG4gICAgY29uc3Qgc3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNbbWVzc2FnZUtleV0gfHwgd2lsZGNhcmRTdHJpbmdpZmllclxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YWx1ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgLy8gdGhpcyBjYXNlIGV4cGxpY2l0bHkgZmFsbHMgdGhyb3VnaCB0byB0aGUgbmV4dCBvbmVcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAoc3RyaW5naWZpZXIpIHZhbHVlID0gc3RyaW5naWZpZXIodmFsdWUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyIHx8IGFzU3RyaW5nKSh2YWx1ZSlcbiAgICAgICAgbXNnU3RyID0gJyxcIicgKyBtZXNzYWdlS2V5ICsgJ1wiOicgKyB2YWx1ZVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgICAgbXNnU3RyID0gJyxcIicgKyBtZXNzYWdlS2V5ICsgJ1wiOicgKyB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzW25lc3RlZEtleVN5bV0gJiYgcHJvcFN0cikge1xuICAgIC8vIHBsYWNlIGFsbCB0aGUgb2JqIHByb3BlcnRpZXMgdW5kZXIgdGhlIHNwZWNpZmllZCBrZXlcbiAgICAvLyB0aGUgbmVzdGVkIGtleSBpcyBhbHJlYWR5IGZvcm1hdHRlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIHJldHVybiBkYXRhICsgdGhpc1tuZXN0ZWRLZXlTdHJTeW1dICsgcHJvcFN0ci5zbGljZSgxKSArICd9JyArIG1zZ1N0ciArIGVuZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkYXRhICsgcHJvcFN0ciArIG1zZ1N0ciArIGVuZFxuICB9XG59XG5cbmZ1bmN0aW9uIGFzQ2hpbmRpbmdzIChpbnN0YW5jZSwgYmluZGluZ3MpIHtcbiAgbGV0IHZhbHVlXG4gIGxldCBkYXRhID0gaW5zdGFuY2VbY2hpbmRpbmdzU3ltXVxuICBjb25zdCBzdHJpbmdpZnkgPSBpbnN0YW5jZVtzdHJpbmdpZnlTeW1dXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSBpbnN0YW5jZVtzdHJpbmdpZnlTYWZlU3ltXVxuICBjb25zdCBzdHJpbmdpZmllcnMgPSBpbnN0YW5jZVtzdHJpbmdpZmllcnNTeW1dXG4gIGNvbnN0IHdpbGRjYXJkU3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNbd2lsZGNhcmRGaXJzdFN5bV1cbiAgY29uc3Qgc2VyaWFsaXplcnMgPSBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1cbiAgY29uc3QgZm9ybWF0dGVyID0gaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0uYmluZGluZ3NcbiAgYmluZGluZ3MgPSBmb3JtYXR0ZXIoYmluZGluZ3MpXG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYmluZGluZ3MpIHtcbiAgICB2YWx1ZSA9IGJpbmRpbmdzW2tleV1cbiAgICBjb25zdCB2YWxpZCA9IChrZXkubGVuZ3RoIDwgNSB8fCAoa2V5ICE9PSAnbGV2ZWwnICYmXG4gICAgICBrZXkgIT09ICdzZXJpYWxpemVycycgJiZcbiAgICAgIGtleSAhPT0gJ2Zvcm1hdHRlcnMnICYmXG4gICAgICBrZXkgIT09ICdjdXN0b21MZXZlbHMnKSkgJiZcbiAgICAgIGJpbmRpbmdzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICBpZiAodmFsaWQgPT09IHRydWUpIHtcbiAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSA/IHNlcmlhbGl6ZXJzW2tleV0odmFsdWUpIDogdmFsdWVcbiAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyc1trZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgZGF0YSArPSAnLFwiJyArIGtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gaGFzQmVlblRhbXBlcmVkIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSAhPT0gc3RyZWFtLmNvbnN0cnVjdG9yLnByb3RvdHlwZS53cml0ZVxufVxuXG5mdW5jdGlvbiBidWlsZFNhZmVTb25pY0Jvb20gKG9wdHMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFNvbmljQm9vbShvcHRzKVxuICBzdHJlYW0ub24oJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgLy8gSWYgd2UgYXJlIHN5bmM6IGZhbHNlLCB3ZSBtdXN0IGZsdXNoIG9uIGV4aXRcbiAgaWYgKCFvcHRzLnN5bmMgJiYgaXNNYWluVGhyZWFkKSB7XG4gICAgb25FeGl0LnJlZ2lzdGVyKHN0cmVhbSwgYXV0b0VuZClcblxuICAgIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvbkV4aXQudW5yZWdpc3RlcihzdHJlYW0pXG4gICAgfSlcbiAgfVxuICByZXR1cm4gc3RyZWFtXG5cbiAgZnVuY3Rpb24gZmlsdGVyQnJva2VuUGlwZSAoZXJyKSB7XG4gICAgLy8gSW1wb3NzaWJsZSB0byByZXBsaWNhdGUgYWNyb3NzIGFsbCBvcGVyYXRpbmcgc3lzdGVtc1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGVyci5jb2RlID09PSAnRVBJUEUnKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgRVBJUEUsIHdlIHNob3VsZCBzdG9wIGxvZ2dpbmcgaGVyZVxuICAgICAgLy8gaG93ZXZlciB3ZSBoYXZlIG5vIGNvbnRyb2wgdG8gdGhlIGNvbnN1bWVyIG9mXG4gICAgICAvLyBTb25pY0Jvb20sIHNvIHdlIGp1c3Qgb3ZlcndyaXRlIHRoZSB3cml0ZSBtZXRob2RcbiAgICAgIHN0cmVhbS53cml0ZSA9IG5vb3BcbiAgICAgIHN0cmVhbS5lbmQgPSBub29wXG4gICAgICBzdHJlYW0uZmx1c2hTeW5jID0gbm9vcFxuICAgICAgc3RyZWFtLmRlc3Ryb3kgPSBub29wXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGZpbHRlckJyb2tlblBpcGUpXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGF1dG9FbmQgKHN0cmVhbSwgZXZlbnROYW1lKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIG9ubHkgb24gc29tZSBwbGF0Zm9ybXNcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChldmVudE5hbWUgPT09ICdiZWZvcmVFeGl0Jykge1xuICAgIC8vIFdlIHN0aWxsIGhhdmUgYW4gZXZlbnQgbG9vcCwgbGV0J3MgdXNlIGl0XG4gICAgc3RyZWFtLmZsdXNoKClcbiAgICBzdHJlYW0ub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgc3RyZWFtLmVuZCgpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGb3Igc29tZSByZWFzb24gaXN0YW5idWwgaXMgbm90IGRldGVjdGluZyB0aGlzLCBidXQgaXQncyB0aGVyZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgLy8gV2UgZG8gbm90IGhhdmUgYW4gZXZlbnQgbG9vcCwgc28gZmx1c2ggc3luY2hyb25vdXNseVxuICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFyZ3NOb3JtYWxpemVyIChkZWZhdWx0T3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXplQXJncyAoaW5zdGFuY2UsIGNhbGxlciwgb3B0cyA9IHt9LCBzdHJlYW0pIHtcbiAgICAvLyBzdXBwb3J0IHN0cmVhbSBhcyBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmVhbSA9IGJ1aWxkU2FmZVNvbmljQm9vbSh7IGRlc3Q6IG9wdHMgfSlcbiAgICAgIG9wdHMgPSB7fVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMudHJhbnNwb3J0KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvbmx5IG9uZSBvZiBvcHRpb24udHJhbnNwb3J0IG9yIHN0cmVhbSBjYW4gYmUgc3BlY2lmaWVkJylcbiAgICAgIH1cbiAgICAgIHN0cmVhbSA9IGJ1aWxkU2FmZVNvbmljQm9vbSh7IGRlc3Q6IHN0cmVhbSB9KVxuICAgIH0gZWxzZSBpZiAob3B0cyBpbnN0YW5jZW9mIFNvbmljQm9vbSB8fCBvcHRzLndyaXRhYmxlIHx8IG9wdHMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHN0cmVhbSA9IG9wdHNcbiAgICAgIG9wdHMgPSB7fVxuICAgIH0gZWxzZSBpZiAob3B0cy50cmFuc3BvcnQpIHtcbiAgICAgIGlmIChvcHRzLnRyYW5zcG9ydCBpbnN0YW5jZW9mIFNvbmljQm9vbSB8fCBvcHRzLnRyYW5zcG9ydC53cml0YWJsZSB8fCBvcHRzLnRyYW5zcG9ydC5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9uLnRyYW5zcG9ydCBkbyBub3QgYWxsb3cgc3RyZWFtLCBwbGVhc2UgcGFzcyB0byBvcHRpb24gZGlyZWN0bHkuIGUuZy4gcGlubyh0cmFuc3BvcnQpJylcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnRyYW5zcG9ydC50YXJnZXRzICYmIG9wdHMudHJhbnNwb3J0LnRhcmdldHMubGVuZ3RoICYmIG9wdHMuZm9ybWF0dGVycyAmJiB0eXBlb2Ygb3B0cy5mb3JtYXR0ZXJzLmxldmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb24udHJhbnNwb3J0LnRhcmdldHMgZG8gbm90IGFsbG93IGN1c3RvbSBsZXZlbCBmb3JtYXR0ZXJzJylcbiAgICAgIH1cblxuICAgICAgbGV0IGN1c3RvbUxldmVsc1xuICAgICAgaWYgKG9wdHMuY3VzdG9tTGV2ZWxzKSB7XG4gICAgICAgIGN1c3RvbUxldmVscyA9IG9wdHMudXNlT25seUN1c3RvbUxldmVscyA/IG9wdHMuY3VzdG9tTGV2ZWxzIDogT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5sZXZlbHMsIG9wdHMuY3VzdG9tTGV2ZWxzKVxuICAgICAgfVxuICAgICAgc3RyZWFtID0gdHJhbnNwb3J0KHsgY2FsbGVyLCAuLi5vcHRzLnRyYW5zcG9ydCwgbGV2ZWxzOiBjdXN0b21MZXZlbHMgfSlcbiAgICB9XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRzKVxuICAgIG9wdHMuc2VyaWFsaXplcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucy5zZXJpYWxpemVycywgb3B0cy5zZXJpYWxpemVycylcbiAgICBvcHRzLmZvcm1hdHRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdHRlcnMpXG5cbiAgICBpZiAob3B0cy5wcmV0dHlQcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmV0dHlQcmludCBvcHRpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgc2VlIHRoZSBwaW5vLXByZXR0eSBwYWNrYWdlIChodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8tcHJldHR5KScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBlbmFibGVkLCBvbkNoaWxkIH0gPSBvcHRzXG4gICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSBvcHRzLmxldmVsID0gJ3NpbGVudCdcbiAgICBpZiAoIW9uQ2hpbGQpIG9wdHMub25DaGlsZCA9IG5vb3BcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgaWYgKCFoYXNCZWVuVGFtcGVyZWQocHJvY2Vzcy5zdGRvdXQpKSB7XG4gICAgICAgIC8vIElmIHByb2Nlc3Muc3Rkb3V0LmZkIGlzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgcnVubmluZ1xuICAgICAgICAvLyBpbiBhIHdvcmtlciB0aHJlYWQuIExldCdzIGFzc3VtZSB3ZSBhcmUgbG9nZ2luZyB0byBmaWxlIGRlc2NyaXB0b3IgMS5cbiAgICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZmQ6IHByb2Nlc3Muc3Rkb3V0LmZkIHx8IDEgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbSA9IHByb2Nlc3Muc3Rkb3V0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG9wdHMsIHN0cmVhbSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHN0cmluZ2lmeVNhZmVGbikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyaW5naWZ5ID0gc3RyaW5naWZ5U2FmZUZuIHx8IHRoaXNbc3RyaW5naWZ5U2FmZVN5bV1cbiAgICAgIHJldHVybiBzdHJpbmdpZnkob2JqKVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiAnXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCInXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGVycyAobGV2ZWwsIGJpbmRpbmdzLCBsb2cpIHtcbiAgcmV0dXJuIHtcbiAgICBsZXZlbCxcbiAgICBiaW5kaW5ncyxcbiAgICBsb2dcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgaW50ZWdlciBmaWxlIGRlc2NyaXB0b3IgdG8gYSBwcm9wZXIgbmF0aXZlIGludGVnZXJcbiAqIGZpbGUgZGVzY3JpcHRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb24gVGhlIGZpbGUgZGVzY3JpcHRvciBzdHJpbmcgdG8gYXR0ZW1wdCB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvciAoZGVzdGluYXRpb24pIHtcbiAgY29uc3QgZmQgPSBOdW1iZXIoZGVzdGluYXRpb24pXG4gIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09ICdzdHJpbmcnICYmIE51bWJlci5pc0Zpbml0ZShmZCkpIHtcbiAgICByZXR1cm4gZmRcbiAgfVxuICAvLyBkZXN0aW5hdGlvbiBjb3VsZCBiZSB1bmRlZmluZWQgaWYgd2UgYXJlIGluIGEgd29ya2VyXG4gIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVGhpcyBpcyBzdGRvdXQgaW4gVU5JWCBzeXN0ZW1zXG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb25cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vb3AsXG4gIGJ1aWxkU2FmZVNvbmljQm9vbSxcbiAgYXNDaGluZGluZ3MsXG4gIGFzSnNvbixcbiAgZ2VuTG9nLFxuICBjcmVhdGVBcmdzTm9ybWFsaXplcixcbiAgc3RyaW5naWZ5LFxuICBidWlsZEZvcm1hdHRlcnMsXG4gIG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvclxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/tools.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/transport.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/transport.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { createRequire } = __webpack_require__(/*! module */ \"module\")\nconst getCallers = __webpack_require__(/*! ./caller */ \"(ssr)/./node_modules/pino/lib/caller.js\")\nconst { join, isAbsolute, sep } = __webpack_require__(/*! node:path */ \"node:path\")\nconst sleep = __webpack_require__(/*! atomic-sleep */ \"(ssr)/./node_modules/atomic-sleep/index.js\")\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(ssr)/./node_modules/on-exit-leak-free/index.js\")\nconst ThreadStream = __webpack_require__(/*! thread-stream */ \"(ssr)/./node_modules/thread-stream/index.js\")\n\nfunction setupOnExit (stream) {\n  // This is leak free, it does not leave event handlers\n  onExit.register(stream, autoEnd)\n  onExit.registerBeforeExit(stream, flush)\n\n  stream.on('close', function () {\n    onExit.unregister(stream)\n  })\n}\n\nfunction buildStream (filename, workerData, workerOpts, sync) {\n  const stream = new ThreadStream({\n    filename,\n    workerData,\n    workerOpts,\n    sync\n  })\n\n  stream.on('ready', onReady)\n  stream.on('close', function () {\n    process.removeListener('exit', onExit)\n  })\n\n  process.on('exit', onExit)\n\n  function onReady () {\n    process.removeListener('exit', onExit)\n    stream.unref()\n\n    if (workerOpts.autoEnd !== false) {\n      setupOnExit(stream)\n    }\n  }\n\n  function onExit () {\n    /* istanbul ignore next */\n    if (stream.closed) {\n      return\n    }\n    stream.flushSync()\n    // Apparently there is a very sporadic race condition\n    // that in certain OS would prevent the messages to be flushed\n    // because the thread might not have been created still.\n    // Unfortunately we need to sleep(100) in this case.\n    sleep(100)\n    stream.end()\n  }\n\n  return stream\n}\n\nfunction autoEnd (stream) {\n  stream.ref()\n  stream.flushSync()\n  stream.end()\n  stream.once('close', function () {\n    stream.unref()\n  })\n}\n\nfunction flush (stream) {\n  stream.flushSync()\n}\n\nfunction transport (fullOptions) {\n  const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions\n\n  const options = {\n    ...fullOptions.options\n  }\n\n  // Backwards compatibility\n  const callers = typeof caller === 'string' ? [caller] : caller\n\n  // This will be eventually modified by bundlers\n  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {}\n\n  let target = fullOptions.target\n\n  if (target && targets) {\n    throw new Error('only one of target or targets can be specified')\n  }\n\n  if (targets) {\n    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js')\n    options.targets = targets.filter(dest => dest.target).map((dest) => {\n      return {\n        ...dest,\n        target: fixTarget(dest.target)\n      }\n    })\n    options.pipelines = targets.filter(dest => dest.pipeline).map((dest) => {\n      return dest.pipeline.map((t) => {\n        return {\n          ...t,\n          level: dest.level, // duplicate the pipeline `level` property defined in the upper level\n          target: fixTarget(t.target)\n        }\n      })\n    })\n  } else if (pipeline) {\n    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js')\n    options.pipelines = [pipeline.map((dest) => {\n      return {\n        ...dest,\n        target: fixTarget(dest.target)\n      }\n    })]\n  }\n\n  if (levels) {\n    options.levels = levels\n  }\n\n  if (dedupe) {\n    options.dedupe = dedupe\n  }\n\n  options.pinoWillSendConfig = true\n\n  return buildStream(fixTarget(target), options, worker, sync)\n\n  function fixTarget (origin) {\n    origin = bundlerOverrides[origin] || origin\n\n    if (isAbsolute(origin) || origin.indexOf('file://') === 0) {\n      return origin\n    }\n\n    if (origin === 'pino/file') {\n      return join(__dirname, '..', 'file.js')\n    }\n\n    let fixTarget\n\n    for (const filePath of callers) {\n      try {\n        const context = filePath === 'node:repl'\n          ? process.cwd() + sep\n          : filePath\n\n        fixTarget = createRequire(context).resolve(origin)\n        break\n      } catch (err) {\n        // Silent catch\n        continue\n      }\n    }\n\n    if (!fixTarget) {\n      throw new Error(`unable to determine transport target for \"${origin}\"`)\n    }\n\n    return fixTarget\n  }\n}\n\nmodule.exports = transport\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx5REFBVTtBQUNyQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckQsY0FBYyxtQkFBTyxDQUFDLGdFQUFjO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywwRUFBbUI7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsa0VBQWU7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhDQUE4Qyx3Q0FBd0M7O0FBRWhHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzPzQzZjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgY3JlYXRlUmVxdWlyZSB9ID0gcmVxdWlyZSgnbW9kdWxlJylcbmNvbnN0IGdldENhbGxlcnMgPSByZXF1aXJlKCcuL2NhbGxlcicpXG5jb25zdCB7IGpvaW4sIGlzQWJzb2x1dGUsIHNlcCB9ID0gcmVxdWlyZSgnbm9kZTpwYXRoJylcbmNvbnN0IHNsZWVwID0gcmVxdWlyZSgnYXRvbWljLXNsZWVwJylcbmNvbnN0IG9uRXhpdCA9IHJlcXVpcmUoJ29uLWV4aXQtbGVhay1mcmVlJylcbmNvbnN0IFRocmVhZFN0cmVhbSA9IHJlcXVpcmUoJ3RocmVhZC1zdHJlYW0nKVxuXG5mdW5jdGlvbiBzZXR1cE9uRXhpdCAoc3RyZWFtKSB7XG4gIC8vIFRoaXMgaXMgbGVhayBmcmVlLCBpdCBkb2VzIG5vdCBsZWF2ZSBldmVudCBoYW5kbGVyc1xuICBvbkV4aXQucmVnaXN0ZXIoc3RyZWFtLCBhdXRvRW5kKVxuICBvbkV4aXQucmVnaXN0ZXJCZWZvcmVFeGl0KHN0cmVhbSwgZmx1c2gpXG5cbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBvbkV4aXQudW5yZWdpc3RlcihzdHJlYW0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RyZWFtIChmaWxlbmFtZSwgd29ya2VyRGF0YSwgd29ya2VyT3B0cywgc3luYykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVGhyZWFkU3RyZWFtKHtcbiAgICBmaWxlbmFtZSxcbiAgICB3b3JrZXJEYXRhLFxuICAgIHdvcmtlck9wdHMsXG4gICAgc3luY1xuICB9KVxuXG4gIHN0cmVhbS5vbigncmVhZHknLCBvblJlYWR5KVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbkV4aXQpXG4gIH0pXG5cbiAgcHJvY2Vzcy5vbignZXhpdCcsIG9uRXhpdClcblxuICBmdW5jdGlvbiBvblJlYWR5ICgpIHtcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25FeGl0KVxuICAgIHN0cmVhbS51bnJlZigpXG5cbiAgICBpZiAod29ya2VyT3B0cy5hdXRvRW5kICE9PSBmYWxzZSkge1xuICAgICAgc2V0dXBPbkV4aXQoc3RyZWFtKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXhpdCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoc3RyZWFtLmNsb3NlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgIC8vIEFwcGFyZW50bHkgdGhlcmUgaXMgYSB2ZXJ5IHNwb3JhZGljIHJhY2UgY29uZGl0aW9uXG4gICAgLy8gdGhhdCBpbiBjZXJ0YWluIE9TIHdvdWxkIHByZXZlbnQgdGhlIG1lc3NhZ2VzIHRvIGJlIGZsdXNoZWRcbiAgICAvLyBiZWNhdXNlIHRoZSB0aHJlYWQgbWlnaHQgbm90IGhhdmUgYmVlbiBjcmVhdGVkIHN0aWxsLlxuICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgbmVlZCB0byBzbGVlcCgxMDApIGluIHRoaXMgY2FzZS5cbiAgICBzbGVlcCgxMDApXG4gICAgc3RyZWFtLmVuZCgpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmZ1bmN0aW9uIGF1dG9FbmQgKHN0cmVhbSkge1xuICBzdHJlYW0ucmVmKClcbiAgc3RyZWFtLmZsdXNoU3luYygpXG4gIHN0cmVhbS5lbmQoKVxuICBzdHJlYW0ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnVucmVmKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmx1c2ggKHN0cmVhbSkge1xuICBzdHJlYW0uZmx1c2hTeW5jKClcbn1cblxuZnVuY3Rpb24gdHJhbnNwb3J0IChmdWxsT3B0aW9ucykge1xuICBjb25zdCB7IHBpcGVsaW5lLCB0YXJnZXRzLCBsZXZlbHMsIGRlZHVwZSwgd29ya2VyID0ge30sIGNhbGxlciA9IGdldENhbGxlcnMoKSwgc3luYyA9IGZhbHNlIH0gPSBmdWxsT3B0aW9uc1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZnVsbE9wdGlvbnMub3B0aW9uc1xuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgY2FsbGVycyA9IHR5cGVvZiBjYWxsZXIgPT09ICdzdHJpbmcnID8gW2NhbGxlcl0gOiBjYWxsZXJcblxuICAvLyBUaGlzIHdpbGwgYmUgZXZlbnR1YWxseSBtb2RpZmllZCBieSBidW5kbGVyc1xuICBjb25zdCBidW5kbGVyT3ZlcnJpZGVzID0gJ19fYnVuZGxlclBhdGhzT3ZlcnJpZGVzJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5fX2J1bmRsZXJQYXRoc092ZXJyaWRlcyA6IHt9XG5cbiAgbGV0IHRhcmdldCA9IGZ1bGxPcHRpb25zLnRhcmdldFxuXG4gIGlmICh0YXJnZXQgJiYgdGFyZ2V0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSBvbmUgb2YgdGFyZ2V0IG9yIHRhcmdldHMgY2FuIGJlIHNwZWNpZmllZCcpXG4gIH1cblxuICBpZiAodGFyZ2V0cykge1xuICAgIHRhcmdldCA9IGJ1bmRsZXJPdmVycmlkZXNbJ3Bpbm8td29ya2VyJ10gfHwgam9pbihfX2Rpcm5hbWUsICd3b3JrZXIuanMnKVxuICAgIG9wdGlvbnMudGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKGRlc3QgPT4gZGVzdC50YXJnZXQpLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVzdCxcbiAgICAgICAgdGFyZ2V0OiBmaXhUYXJnZXQoZGVzdC50YXJnZXQpXG4gICAgICB9XG4gICAgfSlcbiAgICBvcHRpb25zLnBpcGVsaW5lcyA9IHRhcmdldHMuZmlsdGVyKGRlc3QgPT4gZGVzdC5waXBlbGluZSkubWFwKChkZXN0KSA9PiB7XG4gICAgICByZXR1cm4gZGVzdC5waXBlbGluZS5tYXAoKHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50LFxuICAgICAgICAgIGxldmVsOiBkZXN0LmxldmVsLCAvLyBkdXBsaWNhdGUgdGhlIHBpcGVsaW5lIGBsZXZlbGAgcHJvcGVydHkgZGVmaW5lZCBpbiB0aGUgdXBwZXIgbGV2ZWxcbiAgICAgICAgICB0YXJnZXQ6IGZpeFRhcmdldCh0LnRhcmdldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHBpcGVsaW5lKSB7XG4gICAgdGFyZ2V0ID0gYnVuZGxlck92ZXJyaWRlc1sncGluby13b3JrZXInXSB8fCBqb2luKF9fZGlybmFtZSwgJ3dvcmtlci5qcycpXG4gICAgb3B0aW9ucy5waXBlbGluZXMgPSBbcGlwZWxpbmUubWFwKChkZXN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZXN0LFxuICAgICAgICB0YXJnZXQ6IGZpeFRhcmdldChkZXN0LnRhcmdldClcbiAgICAgIH1cbiAgICB9KV1cbiAgfVxuXG4gIGlmIChsZXZlbHMpIHtcbiAgICBvcHRpb25zLmxldmVscyA9IGxldmVsc1xuICB9XG5cbiAgaWYgKGRlZHVwZSkge1xuICAgIG9wdGlvbnMuZGVkdXBlID0gZGVkdXBlXG4gIH1cblxuICBvcHRpb25zLnBpbm9XaWxsU2VuZENvbmZpZyA9IHRydWVcblxuICByZXR1cm4gYnVpbGRTdHJlYW0oZml4VGFyZ2V0KHRhcmdldCksIG9wdGlvbnMsIHdvcmtlciwgc3luYylcblxuICBmdW5jdGlvbiBmaXhUYXJnZXQgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IGJ1bmRsZXJPdmVycmlkZXNbb3JpZ2luXSB8fCBvcmlnaW5cblxuICAgIGlmIChpc0Fic29sdXRlKG9yaWdpbikgfHwgb3JpZ2luLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9yaWdpblxuICAgIH1cblxuICAgIGlmIChvcmlnaW4gPT09ICdwaW5vL2ZpbGUnKSB7XG4gICAgICByZXR1cm4gam9pbihfX2Rpcm5hbWUsICcuLicsICdmaWxlLmpzJylcbiAgICB9XG5cbiAgICBsZXQgZml4VGFyZ2V0XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGNhbGxlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBmaWxlUGF0aCA9PT0gJ25vZGU6cmVwbCdcbiAgICAgICAgICA/IHByb2Nlc3MuY3dkKCkgKyBzZXBcbiAgICAgICAgICA6IGZpbGVQYXRoXG5cbiAgICAgICAgZml4VGFyZ2V0ID0gY3JlYXRlUmVxdWlyZShjb250ZXh0KS5yZXNvbHZlKG9yaWdpbilcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBTaWxlbnQgY2F0Y2hcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpeFRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZGV0ZXJtaW5lIHRyYW5zcG9ydCB0YXJnZXQgZm9yIFwiJHtvcmlnaW59XCJgKVxuICAgIH1cblxuICAgIHJldHVybiBmaXhUYXJnZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/transport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/pino.js":
/*!***********************************!*\
  !*** ./node_modules/pino/pino.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst os = __webpack_require__(/*! node:os */ \"node:os\")\nconst stdSerializers = __webpack_require__(/*! pino-std-serializers */ \"(ssr)/./node_modules/pino-std-serializers/index.js\")\nconst caller = __webpack_require__(/*! ./lib/caller */ \"(ssr)/./node_modules/pino/lib/caller.js\")\nconst redaction = __webpack_require__(/*! ./lib/redaction */ \"(ssr)/./node_modules/pino/lib/redaction.js\")\nconst time = __webpack_require__(/*! ./lib/time */ \"(ssr)/./node_modules/pino/lib/time.js\")\nconst proto = __webpack_require__(/*! ./lib/proto */ \"(ssr)/./node_modules/pino/lib/proto.js\")\nconst symbols = __webpack_require__(/*! ./lib/symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(ssr)/./node_modules/safe-stable-stringify/index.js\")\nconst { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __webpack_require__(/*! ./lib/levels */ \"(ssr)/./node_modules/pino/lib/levels.js\")\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/pino/lib/constants.js\")\nconst {\n  createArgsNormalizer,\n  asChindings,\n  buildSafeSonicBoom,\n  buildFormatters,\n  stringify,\n  normalizeDestFileDescriptor,\n  noop\n} = __webpack_require__(/*! ./lib/tools */ \"(ssr)/./node_modules/pino/lib/tools.js\")\nconst { version } = __webpack_require__(/*! ./lib/meta */ \"(ssr)/./node_modules/pino/lib/meta.js\")\nconst {\n  chindingsSym,\n  redactFmtSym,\n  serializersSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifySafeSym,\n  stringifiersSym,\n  setLevelSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeySym,\n  mixinSym,\n  levelCompSym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym,\n  nestedKeyStrSym,\n  mixinMergeStrategySym,\n  msgPrefixSym\n} = symbols\nconst { epochTime, nullTime } = time\nconst { pid } = process\nconst hostname = os.hostname()\nconst defaultErrorSerializer = stdSerializers.err\nconst defaultOptions = {\n  level: 'info',\n  levelComparison: SORTING_ORDER.ASC,\n  levels: DEFAULT_LEVELS,\n  messageKey: 'msg',\n  errorKey: 'err',\n  nestedKey: null,\n  enabled: true,\n  base: { pid, hostname },\n  serializers: Object.assign(Object.create(null), {\n    err: defaultErrorSerializer\n  }),\n  formatters: Object.assign(Object.create(null), {\n    bindings (bindings) {\n      return bindings\n    },\n    level (label, number) {\n      return { level: number }\n    }\n  }),\n  hooks: {\n    logMethod: undefined,\n    streamWrite: undefined\n  },\n  timestamp: epochTime,\n  name: undefined,\n  redact: null,\n  customLevels: null,\n  useOnlyCustomLevels: false,\n  depthLimit: 5,\n  edgeLimit: 100\n}\n\nconst normalize = createArgsNormalizer(defaultOptions)\n\nconst serializers = Object.assign(Object.create(null), stdSerializers)\n\nfunction pino (...args) {\n  const instance = {}\n  const { opts, stream } = normalize(instance, caller(), ...args)\n\n  if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase()\n\n  const {\n    redact,\n    crlf,\n    serializers,\n    timestamp,\n    messageKey,\n    errorKey,\n    nestedKey,\n    base,\n    name,\n    level,\n    customLevels,\n    levelComparison,\n    mixin,\n    mixinMergeStrategy,\n    useOnlyCustomLevels,\n    formatters,\n    hooks,\n    depthLimit,\n    edgeLimit,\n    onChild,\n    msgPrefix\n  } = opts\n\n  const stringifySafe = configure({\n    maximumDepth: depthLimit,\n    maximumBreadth: edgeLimit\n  })\n\n  const allFormatters = buildFormatters(\n    formatters.level,\n    formatters.bindings,\n    formatters.log\n  )\n\n  const stringifyFn = stringify.bind({\n    [stringifySafeSym]: stringifySafe\n  })\n  const stringifiers = redact ? redaction(redact, stringifyFn) : {}\n  const formatOpts = redact\n    ? { stringify: stringifiers[redactFmtSym] }\n    : { stringify: stringifyFn }\n  const end = '}' + (crlf ? '\\r\\n' : '\\n')\n  const coreChindings = asChindings.bind(null, {\n    [chindingsSym]: '',\n    [serializersSym]: serializers,\n    [stringifiersSym]: stringifiers,\n    [stringifySym]: stringify,\n    [stringifySafeSym]: stringifySafe,\n    [formattersSym]: allFormatters\n  })\n\n  let chindings = ''\n  if (base !== null) {\n    if (name === undefined) {\n      chindings = coreChindings(base)\n    } else {\n      chindings = coreChindings(Object.assign({}, base, { name }))\n    }\n  }\n\n  const time = (timestamp instanceof Function)\n    ? timestamp\n    : (timestamp ? epochTime : nullTime)\n  const timeSliceIndex = time().indexOf(':') + 1\n\n  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')\n  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type \"${typeof mixin}\" - expected \"function\"`)\n  if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type \"${typeof msgPrefix}\" - expected \"string\"`)\n\n  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels)\n  const levels = mappings(customLevels, useOnlyCustomLevels)\n\n  if (typeof stream.emit === 'function') {\n    stream.emit('message', { code: 'PINO_CONFIG', config: { levels, messageKey, errorKey } })\n  }\n\n  assertLevelComparison(levelComparison)\n  const levelCompFunc = genLevelComparison(levelComparison)\n\n  Object.assign(instance, {\n    levels,\n    [levelCompSym]: levelCompFunc,\n    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,\n    [streamSym]: stream,\n    [timeSym]: time,\n    [timeSliceIndexSym]: timeSliceIndex,\n    [stringifySym]: stringify,\n    [stringifySafeSym]: stringifySafe,\n    [stringifiersSym]: stringifiers,\n    [endSym]: end,\n    [formatOptsSym]: formatOpts,\n    [messageKeySym]: messageKey,\n    [errorKeySym]: errorKey,\n    [nestedKeySym]: nestedKey,\n    // protect against injection\n    [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',\n    [serializersSym]: serializers,\n    [mixinSym]: mixin,\n    [mixinMergeStrategySym]: mixinMergeStrategy,\n    [chindingsSym]: chindings,\n    [formattersSym]: allFormatters,\n    [hooksSym]: hooks,\n    silent: noop,\n    onChild,\n    [msgPrefixSym]: msgPrefix\n  })\n\n  Object.setPrototypeOf(instance, proto())\n\n  genLsCache(instance)\n\n  instance[setLevelSym](level)\n\n  return instance\n}\n\nmodule.exports = pino\n\nmodule.exports.destination = (dest = process.stdout.fd) => {\n  if (typeof dest === 'object') {\n    dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd)\n    return buildSafeSonicBoom(dest)\n  } else {\n    return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 })\n  }\n}\n\nmodule.exports.transport = __webpack_require__(/*! ./lib/transport */ \"(ssr)/./node_modules/pino/lib/transport.js\")\nmodule.exports.multistream = __webpack_require__(/*! ./lib/multistream */ \"(ssr)/./node_modules/pino/lib/multistream.js\")\n\nmodule.exports.levels = mappings()\nmodule.exports.stdSerializers = serializers\nmodule.exports.stdTimeFunctions = Object.assign({}, time)\nmodule.exports.symbols = symbols\nmodule.exports.version = version\n\n// Enables default and name export with TypeScript and Babel\nmodule.exports[\"default\"] = pino\nmodule.exports.pino = pino\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9waW5vLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyx3QkFBUztBQUM1Qix1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDZEQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFpQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMseURBQVk7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDJEQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFlO0FBQ3ZDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0ZBQXVCO0FBQ3JELFFBQVEsMkZBQTJGLEVBQUUsbUJBQU8sQ0FBQyw2REFBYztBQUMzSCxRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsbUVBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBYTtBQUN6QixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLHlEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixRQUFRLHNCQUFzQjtBQUM5QixRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxlQUFlOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsVUFBVSxNQUFNO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsYUFBYTtBQUM1Rix5RkFBeUYsaUJBQWlCOztBQUUxRztBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLCtCQUErQixnQ0FBZ0M7QUFDNUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEIsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQ0FBZ0MsdURBQXVEO0FBQ3ZGO0FBQ0E7O0FBRUEsbUhBQXFEO0FBQ3JELHlIQUF5RDs7QUFFekQscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3QiwrQkFBK0IsbUJBQW1CO0FBQ2xELHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0EseUJBQXNCO0FBQ3RCLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcGluby9waW5vLmpzPzE2NDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnbm9kZTpvcycpXG5jb25zdCBzdGRTZXJpYWxpemVycyA9IHJlcXVpcmUoJ3Bpbm8tc3RkLXNlcmlhbGl6ZXJzJylcbmNvbnN0IGNhbGxlciA9IHJlcXVpcmUoJy4vbGliL2NhbGxlcicpXG5jb25zdCByZWRhY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9yZWRhY3Rpb24nKVxuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vbGliL3RpbWUnKVxuY29uc3QgcHJvdG8gPSByZXF1aXJlKCcuL2xpYi9wcm90bycpXG5jb25zdCBzeW1ib2xzID0gcmVxdWlyZSgnLi9saWIvc3ltYm9scycpXG5jb25zdCB7IGNvbmZpZ3VyZSB9ID0gcmVxdWlyZSgnc2FmZS1zdGFibGUtc3RyaW5naWZ5JylcbmNvbnN0IHsgYXNzZXJ0RGVmYXVsdExldmVsRm91bmQsIG1hcHBpbmdzLCBnZW5Mc0NhY2hlLCBnZW5MZXZlbENvbXBhcmlzb24sIGFzc2VydExldmVsQ29tcGFyaXNvbiB9ID0gcmVxdWlyZSgnLi9saWIvbGV2ZWxzJylcbmNvbnN0IHsgREVGQVVMVF9MRVZFTFMsIFNPUlRJTkdfT1JERVIgfSA9IHJlcXVpcmUoJy4vbGliL2NvbnN0YW50cycpXG5jb25zdCB7XG4gIGNyZWF0ZUFyZ3NOb3JtYWxpemVyLFxuICBhc0NoaW5kaW5ncyxcbiAgYnVpbGRTYWZlU29uaWNCb29tLFxuICBidWlsZEZvcm1hdHRlcnMsXG4gIHN0cmluZ2lmeSxcbiAgbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yLFxuICBub29wXG59ID0gcmVxdWlyZSgnLi9saWIvdG9vbHMnKVxuY29uc3QgeyB2ZXJzaW9uIH0gPSByZXF1aXJlKCcuL2xpYi9tZXRhJylcbmNvbnN0IHtcbiAgY2hpbmRpbmdzU3ltLFxuICByZWRhY3RGbXRTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICB0aW1lU3ltLFxuICB0aW1lU2xpY2VJbmRleFN5bSxcbiAgc3RyZWFtU3ltLFxuICBzdHJpbmdpZnlTeW0sXG4gIHN0cmluZ2lmeVNhZmVTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgc2V0TGV2ZWxTeW0sXG4gIGVuZFN5bSxcbiAgZm9ybWF0T3B0c1N5bSxcbiAgbWVzc2FnZUtleVN5bSxcbiAgZXJyb3JLZXlTeW0sXG4gIG5lc3RlZEtleVN5bSxcbiAgbWl4aW5TeW0sXG4gIGxldmVsQ29tcFN5bSxcbiAgdXNlT25seUN1c3RvbUxldmVsc1N5bSxcbiAgZm9ybWF0dGVyc1N5bSxcbiAgaG9va3NTeW0sXG4gIG5lc3RlZEtleVN0clN5bSxcbiAgbWl4aW5NZXJnZVN0cmF0ZWd5U3ltLFxuICBtc2dQcmVmaXhTeW1cbn0gPSBzeW1ib2xzXG5jb25zdCB7IGVwb2NoVGltZSwgbnVsbFRpbWUgfSA9IHRpbWVcbmNvbnN0IHsgcGlkIH0gPSBwcm9jZXNzXG5jb25zdCBob3N0bmFtZSA9IG9zLmhvc3RuYW1lKClcbmNvbnN0IGRlZmF1bHRFcnJvclNlcmlhbGl6ZXIgPSBzdGRTZXJpYWxpemVycy5lcnJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBsZXZlbDogJ2luZm8nLFxuICBsZXZlbENvbXBhcmlzb246IFNPUlRJTkdfT1JERVIuQVNDLFxuICBsZXZlbHM6IERFRkFVTFRfTEVWRUxTLFxuICBtZXNzYWdlS2V5OiAnbXNnJyxcbiAgZXJyb3JLZXk6ICdlcnInLFxuICBuZXN0ZWRLZXk6IG51bGwsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIGJhc2U6IHsgcGlkLCBob3N0bmFtZSB9LFxuICBzZXJpYWxpemVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgZXJyOiBkZWZhdWx0RXJyb3JTZXJpYWxpemVyXG4gIH0pLFxuICBmb3JtYXR0ZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICBiaW5kaW5ncyAoYmluZGluZ3MpIHtcbiAgICAgIHJldHVybiBiaW5kaW5nc1xuICAgIH0sXG4gICAgbGV2ZWwgKGxhYmVsLCBudW1iZXIpIHtcbiAgICAgIHJldHVybiB7IGxldmVsOiBudW1iZXIgfVxuICAgIH1cbiAgfSksXG4gIGhvb2tzOiB7XG4gICAgbG9nTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgc3RyZWFtV3JpdGU6IHVuZGVmaW5lZFxuICB9LFxuICB0aW1lc3RhbXA6IGVwb2NoVGltZSxcbiAgbmFtZTogdW5kZWZpbmVkLFxuICByZWRhY3Q6IG51bGwsXG4gIGN1c3RvbUxldmVsczogbnVsbCxcbiAgdXNlT25seUN1c3RvbUxldmVsczogZmFsc2UsXG4gIGRlcHRoTGltaXQ6IDUsXG4gIGVkZ2VMaW1pdDogMTAwXG59XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IGNyZWF0ZUFyZ3NOb3JtYWxpemVyKGRlZmF1bHRPcHRpb25zKVxuXG5jb25zdCBzZXJpYWxpemVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgc3RkU2VyaWFsaXplcnMpXG5cbmZ1bmN0aW9uIHBpbm8gKC4uLmFyZ3MpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7fVxuICBjb25zdCB7IG9wdHMsIHN0cmVhbSB9ID0gbm9ybWFsaXplKGluc3RhbmNlLCBjYWxsZXIoKSwgLi4uYXJncylcblxuICBpZiAob3B0cy5sZXZlbCAmJiB0eXBlb2Ygb3B0cy5sZXZlbCA9PT0gJ3N0cmluZycgJiYgREVGQVVMVF9MRVZFTFNbb3B0cy5sZXZlbC50b0xvd2VyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSBvcHRzLmxldmVsID0gb3B0cy5sZXZlbC50b0xvd2VyQ2FzZSgpXG5cbiAgY29uc3Qge1xuICAgIHJlZGFjdCxcbiAgICBjcmxmLFxuICAgIHNlcmlhbGl6ZXJzLFxuICAgIHRpbWVzdGFtcCxcbiAgICBtZXNzYWdlS2V5LFxuICAgIGVycm9yS2V5LFxuICAgIG5lc3RlZEtleSxcbiAgICBiYXNlLFxuICAgIG5hbWUsXG4gICAgbGV2ZWwsXG4gICAgY3VzdG9tTGV2ZWxzLFxuICAgIGxldmVsQ29tcGFyaXNvbixcbiAgICBtaXhpbixcbiAgICBtaXhpbk1lcmdlU3RyYXRlZ3ksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGhvb2tzLFxuICAgIGRlcHRoTGltaXQsXG4gICAgZWRnZUxpbWl0LFxuICAgIG9uQ2hpbGQsXG4gICAgbXNnUHJlZml4XG4gIH0gPSBvcHRzXG5cbiAgY29uc3Qgc3RyaW5naWZ5U2FmZSA9IGNvbmZpZ3VyZSh7XG4gICAgbWF4aW11bURlcHRoOiBkZXB0aExpbWl0LFxuICAgIG1heGltdW1CcmVhZHRoOiBlZGdlTGltaXRcbiAgfSlcblxuICBjb25zdCBhbGxGb3JtYXR0ZXJzID0gYnVpbGRGb3JtYXR0ZXJzKFxuICAgIGZvcm1hdHRlcnMubGV2ZWwsXG4gICAgZm9ybWF0dGVycy5iaW5kaW5ncyxcbiAgICBmb3JtYXR0ZXJzLmxvZ1xuICApXG5cbiAgY29uc3Qgc3RyaW5naWZ5Rm4gPSBzdHJpbmdpZnkuYmluZCh7XG4gICAgW3N0cmluZ2lmeVNhZmVTeW1dOiBzdHJpbmdpZnlTYWZlXG4gIH0pXG4gIGNvbnN0IHN0cmluZ2lmaWVycyA9IHJlZGFjdCA/IHJlZGFjdGlvbihyZWRhY3QsIHN0cmluZ2lmeUZuKSA6IHt9XG4gIGNvbnN0IGZvcm1hdE9wdHMgPSByZWRhY3RcbiAgICA/IHsgc3RyaW5naWZ5OiBzdHJpbmdpZmllcnNbcmVkYWN0Rm10U3ltXSB9XG4gICAgOiB7IHN0cmluZ2lmeTogc3RyaW5naWZ5Rm4gfVxuICBjb25zdCBlbmQgPSAnfScgKyAoY3JsZiA/ICdcXHJcXG4nIDogJ1xcbicpXG4gIGNvbnN0IGNvcmVDaGluZGluZ3MgPSBhc0NoaW5kaW5ncy5iaW5kKG51bGwsIHtcbiAgICBbY2hpbmRpbmdzU3ltXTogJycsXG4gICAgW3NlcmlhbGl6ZXJzU3ltXTogc2VyaWFsaXplcnMsXG4gICAgW3N0cmluZ2lmaWVyc1N5bV06IHN0cmluZ2lmaWVycyxcbiAgICBbc3RyaW5naWZ5U3ltXTogc3RyaW5naWZ5LFxuICAgIFtzdHJpbmdpZnlTYWZlU3ltXTogc3RyaW5naWZ5U2FmZSxcbiAgICBbZm9ybWF0dGVyc1N5bV06IGFsbEZvcm1hdHRlcnNcbiAgfSlcblxuICBsZXQgY2hpbmRpbmdzID0gJydcbiAgaWYgKGJhc2UgIT09IG51bGwpIHtcbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGluZGluZ3MgPSBjb3JlQ2hpbmRpbmdzKGJhc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaW5kaW5ncyA9IGNvcmVDaGluZGluZ3MoT2JqZWN0LmFzc2lnbih7fSwgYmFzZSwgeyBuYW1lIH0pKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRpbWUgPSAodGltZXN0YW1wIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgPyB0aW1lc3RhbXBcbiAgICA6ICh0aW1lc3RhbXAgPyBlcG9jaFRpbWUgOiBudWxsVGltZSlcbiAgY29uc3QgdGltZVNsaWNlSW5kZXggPSB0aW1lKCkuaW5kZXhPZignOicpICsgMVxuXG4gIGlmICh1c2VPbmx5Q3VzdG9tTGV2ZWxzICYmICFjdXN0b21MZXZlbHMpIHRocm93IEVycm9yKCdjdXN0b21MZXZlbHMgaXMgcmVxdWlyZWQgaWYgdXNlT25seUN1c3RvbUxldmVscyBpcyBzZXQgdHJ1ZScpXG4gIGlmIChtaXhpbiAmJiB0eXBlb2YgbWl4aW4gIT09ICdmdW5jdGlvbicpIHRocm93IEVycm9yKGBVbmtub3duIG1peGluIHR5cGUgXCIke3R5cGVvZiBtaXhpbn1cIiAtIGV4cGVjdGVkIFwiZnVuY3Rpb25cImApXG4gIGlmIChtc2dQcmVmaXggJiYgdHlwZW9mIG1zZ1ByZWZpeCAhPT0gJ3N0cmluZycpIHRocm93IEVycm9yKGBVbmtub3duIG1zZ1ByZWZpeCB0eXBlIFwiJHt0eXBlb2YgbXNnUHJlZml4fVwiIC0gZXhwZWN0ZWQgXCJzdHJpbmdcImApXG5cbiAgYXNzZXJ0RGVmYXVsdExldmVsRm91bmQobGV2ZWwsIGN1c3RvbUxldmVscywgdXNlT25seUN1c3RvbUxldmVscylcbiAgY29uc3QgbGV2ZWxzID0gbWFwcGluZ3MoY3VzdG9tTGV2ZWxzLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJlYW0uZW1pdCgnbWVzc2FnZScsIHsgY29kZTogJ1BJTk9fQ09ORklHJywgY29uZmlnOiB7IGxldmVscywgbWVzc2FnZUtleSwgZXJyb3JLZXkgfSB9KVxuICB9XG5cbiAgYXNzZXJ0TGV2ZWxDb21wYXJpc29uKGxldmVsQ29tcGFyaXNvbilcbiAgY29uc3QgbGV2ZWxDb21wRnVuYyA9IGdlbkxldmVsQ29tcGFyaXNvbihsZXZlbENvbXBhcmlzb24pXG5cbiAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgIGxldmVscyxcbiAgICBbbGV2ZWxDb21wU3ltXTogbGV2ZWxDb21wRnVuYyxcbiAgICBbdXNlT25seUN1c3RvbUxldmVsc1N5bV06IHVzZU9ubHlDdXN0b21MZXZlbHMsXG4gICAgW3N0cmVhbVN5bV06IHN0cmVhbSxcbiAgICBbdGltZVN5bV06IHRpbWUsXG4gICAgW3RpbWVTbGljZUluZGV4U3ltXTogdGltZVNsaWNlSW5kZXgsXG4gICAgW3N0cmluZ2lmeVN5bV06IHN0cmluZ2lmeSxcbiAgICBbc3RyaW5naWZ5U2FmZVN5bV06IHN0cmluZ2lmeVNhZmUsXG4gICAgW3N0cmluZ2lmaWVyc1N5bV06IHN0cmluZ2lmaWVycyxcbiAgICBbZW5kU3ltXTogZW5kLFxuICAgIFtmb3JtYXRPcHRzU3ltXTogZm9ybWF0T3B0cyxcbiAgICBbbWVzc2FnZUtleVN5bV06IG1lc3NhZ2VLZXksXG4gICAgW2Vycm9yS2V5U3ltXTogZXJyb3JLZXksXG4gICAgW25lc3RlZEtleVN5bV06IG5lc3RlZEtleSxcbiAgICAvLyBwcm90ZWN0IGFnYWluc3QgaW5qZWN0aW9uXG4gICAgW25lc3RlZEtleVN0clN5bV06IG5lc3RlZEtleSA/IGAsJHtKU09OLnN0cmluZ2lmeShuZXN0ZWRLZXkpfTp7YCA6ICcnLFxuICAgIFtzZXJpYWxpemVyc1N5bV06IHNlcmlhbGl6ZXJzLFxuICAgIFttaXhpblN5bV06IG1peGluLFxuICAgIFttaXhpbk1lcmdlU3RyYXRlZ3lTeW1dOiBtaXhpbk1lcmdlU3RyYXRlZ3ksXG4gICAgW2NoaW5kaW5nc1N5bV06IGNoaW5kaW5ncyxcbiAgICBbZm9ybWF0dGVyc1N5bV06IGFsbEZvcm1hdHRlcnMsXG4gICAgW2hvb2tzU3ltXTogaG9va3MsXG4gICAgc2lsZW50OiBub29wLFxuICAgIG9uQ2hpbGQsXG4gICAgW21zZ1ByZWZpeFN5bV06IG1zZ1ByZWZpeFxuICB9KVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgcHJvdG8oKSlcblxuICBnZW5Mc0NhY2hlKGluc3RhbmNlKVxuXG4gIGluc3RhbmNlW3NldExldmVsU3ltXShsZXZlbClcblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaW5vXG5cbm1vZHVsZS5leHBvcnRzLmRlc3RpbmF0aW9uID0gKGRlc3QgPSBwcm9jZXNzLnN0ZG91dC5mZCkgPT4ge1xuICBpZiAodHlwZW9mIGRlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgZGVzdC5kZXN0ID0gbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yKGRlc3QuZGVzdCB8fCBwcm9jZXNzLnN0ZG91dC5mZClcbiAgICByZXR1cm4gYnVpbGRTYWZlU29uaWNCb29tKGRlc3QpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1aWxkU2FmZVNvbmljQm9vbSh7IGRlc3Q6IG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvcihkZXN0KSwgbWluTGVuZ3RoOiAwIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMudHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0Jylcbm1vZHVsZS5leHBvcnRzLm11bHRpc3RyZWFtID0gcmVxdWlyZSgnLi9saWIvbXVsdGlzdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cy5sZXZlbHMgPSBtYXBwaW5ncygpXG5tb2R1bGUuZXhwb3J0cy5zdGRTZXJpYWxpemVycyA9IHNlcmlhbGl6ZXJzXG5tb2R1bGUuZXhwb3J0cy5zdGRUaW1lRnVuY3Rpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGltZSlcbm1vZHVsZS5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvblxuXG4vLyBFbmFibGVzIGRlZmF1bHQgYW5kIG5hbWUgZXhwb3J0IHdpdGggVHlwZVNjcmlwdCBhbmQgQmFiZWxcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwaW5vXG5tb2R1bGUuZXhwb3J0cy5waW5vID0gcGlub1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/pino.js\n");

/***/ })

};
;